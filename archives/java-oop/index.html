<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0"><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.gtn1024.me","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="Java 作为一门纯面向对象的编程语言，对于面向对象有着深刻的了解是必备的。"><meta property="og:type" content="article"><meta property="og:title" content="Java 面向对象知识详解"><meta property="og:url" content="https://blog.gtn1024.me/archives/java-oop/index.html"><meta property="og:site_name" content="巴掌大叔的博客"><meta property="og:description" content="Java 作为一门纯面向对象的编程语言，对于面向对象有着深刻的了解是必备的。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.gtn1024.me/archives/java-oop/16317985375578.jpg"><meta property="og:image" content="https://blog.gtn1024.me/archives/java-oop/16323961305864.jpg"><meta property="og:image" content="https://blog.gtn1024.me/archives/java-oop/16322017907275.jpg"><meta property="article:published_time" content="2021-09-16T02:59:18.000Z"><meta property="article:modified_time" content="2022-02-01T04:35:14.000Z"><meta property="article:author" content="Taoning Ge"><meta property="article:tag" content="Java"><meta property="article:tag" content="面向对象"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.gtn1024.me/archives/java-oop/16317985375578.jpg"><link rel="canonical" href="https://blog.gtn1024.me/archives/java-oop/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.gtn1024.me/archives/java-oop/","path":"archives/java-oop/","title":"Java 面向对象知识详解"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java 面向对象知识详解 | 巴掌大叔的博客</title><script>!function(t,e,n,c,s,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(s=e.createElement(c)).async=1,s.src="https://www.clarity.ms/tag/cnwsn0j9pq",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(s,a)}(window,document,"clarity","script")</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">巴掌大叔的博客</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#tldr"><span class="nav-number">1.</span> <span class="nav-text">TL;DR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">初识面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">定义类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">3.4.</span> <span class="nav-text">构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.</span> <span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">4.1.</span> <span class="nav-text">访问控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">4.2.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">4.3.</span> <span class="nav-text">this</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#this-%E5%BC%95%E7%94%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text">this 引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this-%E8%B0%83%E7%94%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">this 调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">4.4.</span> <span class="nav-text">super</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#super-%E9%99%90%E5%AE%9A"><span class="nav-number">4.4.1.</span> <span class="nav-text">super 限定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">4.4.2.</span> <span class="nav-text">调用父类构造器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">4.5.</span> <span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#final%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="nav-number">4.5.1.</span> <span class="nav-text">final修饰变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final%E7%9A%84%E5%AE%8F%E6%9B%BF%E6%8D%A2"><span class="nav-number">4.5.2.</span> <span class="nav-text">final的宏替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-number">4.5.3.</span> <span class="nav-text">final修饰方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="nav-number">4.5.4.</span> <span class="nav-text">final修饰类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#abstract"><span class="nav-number">4.6.</span> <span class="nav-text">abstract</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">4.6.1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">4.6.2.</span> <span class="nav-text">抽象方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">5.</span> <span class="nav-text">面向对象三大特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">5.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">5.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">5.3.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">变量的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">向上转型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.3.3.</span> <span class="nav-text">向下转型 (强制转换)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof"><span class="nav-number">5.3.4.</span> <span class="nav-text">instanceof</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%87%8D%E7%82%B9"><span class="nav-number">6.</span> <span class="nav-text">面向对象重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="nav-number">6.1.</span> <span class="nav-text">方法重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E9%87%8D%E8%BD%BD"><span class="nav-number">6.2.</span> <span class="nav-text">构造器重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="nav-number">6.3.</span> <span class="nav-text">方法重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tostring-%E4%B8%8E-equals-%E6%96%B9%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">toString 与 equals 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="nav-number">6.5.</span> <span class="nav-text">初始化块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="nav-number">6.5.1.</span> <span class="nav-text">实例初始化块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="nav-number">6.5.2.</span> <span class="nav-text">类初始化块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-1"><span class="nav-number">6.6.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.7.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-number">6.7.1.</span> <span class="nav-text">接口定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.7.2.</span> <span class="nav-text">使用接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.7.3.</span> <span class="nav-text">实现接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">6.8.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%8C%BA%E5%88%86%E5%90%8C%E5%90%8D%E5%8F%98%E9%87%8F"><span class="nav-number">6.8.1.</span> <span class="nav-text">内部类区分同名变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">6.8.2.</span> <span class="nav-text">使用内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">6.8.3.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">6.8.4.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">6.9.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%8Eswitch"><span class="nav-number">6.9.1.</span> <span class="nav-text">枚举与switch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">6.9.2.</span> <span class="nav-text">枚举类与构造器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#n-more-things"><span class="nav-number">7.</span> <span class="nav-text">N More Things</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">记录类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E4%B8%AA%E6%95%B0%E5%8F%AF%E5%8F%98%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">形参个数可变方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">7.3.</span> <span class="nav-text">Java 8 函数式编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-9-%E6%8E%A5%E5%8F%A3%E7%9A%84-private-%E6%96%B9%E6%B3%95"><span class="nav-number">7.4.</span> <span class="nav-text">Java 9 接口的 private 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-16-%E5%A2%9E%E5%BC%BA%E7%9A%84-instanceof"><span class="nav-number">7.5.</span> <span class="nav-text">Java 16 增强的 instanceof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Taoning Ge" src="https://github.com/gtn1024.png"><p class="site-author-name" itemprop="name">Taoning Ge</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/gtn1024" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gtn1024" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:gtn1024@foxmail.com" title="E-Mail → mailto:gtn1024@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.kankanzhijian.com/" title="https:&#x2F;&#x2F;www.kankanzhijian.com&#x2F;" rel="noopener" target="_blank">牧云踏歌的博客</a></li><li class="links-of-blogroll-item"><a href="https://xiaoheiit6.github.io/" title="https:&#x2F;&#x2F;xiaoheiit6.github.io&#x2F;" rel="noopener" target="_blank">小黑的博客</a></li><li class="links-of-blogroll-item"><a href="https://blog.ackow129.top/" title="https:&#x2F;&#x2F;blog.ackow129.top&#x2F;" rel="noopener" target="_blank">Ackow</a></li></ul></div></div><div class="pjax"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.gtn1024.me/archives/java-oop/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://github.com/gtn1024.png"><meta itemprop="name" content="Taoning Ge"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="巴掌大叔的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java 面向对象知识详解 | 巴掌大叔的博客"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java 面向对象知识详解</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-09-16 10:59:18" itemprop="dateCreated datePublished" datetime="2021-09-16T10:59:18+08:00">2021-09-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-01 12:35:14" itemprop="dateModified" datetime="2022-02-01T12:35:14+08:00">2022-02-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Java 作为一门纯面向对象的编程语言，对于面向对象有着深刻的了解是必备的。</p><span id="more"></span><h2 id="tldr">TL;DR</h2><p>面向对象 3 大类型：<strong>类</strong>、<strong>接口</strong>、<strong>枚举</strong>。</p><p>面向对象 4 大修饰符：<code>private</code> | <code>protected</code> | <code>public</code>(互斥)、<code>static</code>、<code>final</code>、<code>abstract</code>。</p><p>面向对象 5 大成员：<strong>成员变量</strong>、<strong>方法</strong>、<strong>构造器</strong>、<strong>初始化块</strong>、<strong>内部类</strong>。</p><h2 id="总述">总述</h2><p><strong>面向对象编程</strong>(Object-Oriented Programming, 简称 <strong>OOP</strong>)是一种编程范式。</p><p>在<strong>面向对象编程</strong>中，有两个重要的概念：</p><ul><li><strong>类</strong>：一类事物的统称（例如<strong>动物</strong>类）</li><li><strong>对象</strong>：某个<strong>类</strong>中的实例（例如<strong>狗</strong>、<strong>猫</strong>）</li></ul><p>在一个类中，有<strong>成员变量</strong>(<strong>field</strong>)、<strong>方法</strong>(<strong>method</strong>)、<strong>构造器</strong>(<strong>constructor</strong>)、<strong>初始化块</strong>、<strong>内部类</strong>(<strong>nested class</strong>)五大成员。</p><p><strong>牢记</strong>：</p><p><strong>始终只定义你所关心的项目！</strong></p><p><strong>始终只定义你所关心的项目！</strong></p><p><strong>始终只定义你所关心的项目！</strong></p><p>举个例子：现定义一个<strong>人类</strong>(<strong>Human</strong>)，<strong>成员变量</strong>可以有<strong>姓名</strong>(<strong>name</strong>)、<strong>性别</strong>(<strong>gender</strong>)、<strong>年龄</strong>(<strong>age</strong>)、<strong>身高</strong>(<strong>height</strong>)、<strong>体重</strong>(<strong>weight</strong>)等，<strong>方法</strong>可以有<strong>走</strong>(<strong>walk</strong>)、<strong>跑</strong>(<strong>run</strong>)、<strong>跳</strong>(<strong>jump</strong>)、<strong>吃</strong>(<strong>eat</strong>)等。</p><p>对应的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unified_Modeling_Language">UML 图</a>为：</p><img src="/archives/java-oop/16317985375578.jpg"><h2 id="初识面向对象">初识面向对象</h2><h3 id="定义类">定义类</h3><p>在 Java 中，定义<strong>类</strong>的统一格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>修饰符</strong>（<strong>可省略</strong>）中的<strong>访问权限</strong>只能为<code>public</code>（<strong>公开类</strong>），其他<strong>修饰符</strong>只能为<code>final</code>或<code>abstract</code>(<strong>抽象类</strong>)。</p><p><strong>类名</strong>则为<strong>合法的标识符</strong>，一般采用<strong>大驼峰命名法</strong>来表示。（详见 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Camel_case">驼峰命名法</a> ）</p><h3 id="成员变量">成员变量</h3><p>在 Java 中，定义<strong>成员变量</strong>的统一格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类型 成员变量名 [= 初始值];</span><br></pre></td></tr></table></figure><p>其中，<strong>修饰符</strong>（<strong>可省略</strong>）中的<strong>访问权限</strong>可以为<code>public</code>|<code>protected</code>|<code>private</code>。其他<strong>修饰符</strong>可以为<code>final</code>、<code>static</code>。</p><p><strong>类型</strong>可以为任意的<strong>基本类型</strong>或<strong>引用类型</strong>。</p><p><strong>成员变量名</strong>同样为<strong>合法的标识符</strong>，一般采用<strong>小驼峰命名法</strong>来表示。<strong>成员变量名</strong>通常为<strong>名词</strong>（如<strong>身高</strong>、<strong>体重</strong>）。</p><p><strong>初始值</strong>可以省略，如不显式指定初始值则为该类型的默认值（数值型为<code>0</code>，布尔型为<code>False</code>，引用类型为<code>null</code>）。</p><h3 id="方法">方法</h3><p>在 Java 中，<strong>方法</strong>必须定义在<strong>类</strong>中，不能单独存在。定义<strong>方法</strong>的统一格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名( [形参列表] ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果声明了返回值类型，必须有 return 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>修饰符</strong>（<strong>可省略</strong>）中的<strong>访问权限</strong>可以为<code>public</code>|<code>protected</code>|<code>private</code>。其他<strong>修饰符</strong>可以为<code>final</code>|<code>abstract</code>、<code>static</code>。</p><p><strong>返回值类型</strong>可以为任意的<strong>基本类型</strong>或<strong>引用类型</strong>，也可以为<code>void</code>（无返回值）。</p><p><strong>方法名</strong>为<strong>合法的标识符</strong>，一般采用<strong>小驼峰命名法</strong>来表示。<strong>方法名</strong>通常为<strong>动词</strong>（如<strong>走</strong>、<strong>跑</strong>）。</p><h3 id="构造器">构造器</h3><p><strong>构造器</strong>的作用是在<code>new</code>一个对象时自动执行的方法。如果没有为类创建构造器，Java 会<strong>自动</strong>创建一个<strong>无参构造器</strong>。</p><p>在 Java 中，定义<strong>构造器</strong>的统一格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类名( [形参列表] ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：构造器名只能与类名相同，且不能写返回值类型</strong></p><p>其中，<strong>修饰符</strong>（<strong>可省略</strong>）只能为<code>public</code>|<code>protected</code>|<code>private</code>。</p><h2 id="关键字">关键字</h2><h3 id="访问控制">访问控制</h3><p>Java 面向对象中访问权限有 3 个（从小到大排序）：</p><ul><li><code>private</code>：<strong>类访问权限</strong>，只能在该类中被访问（彻底隐藏）。</li><li><strong>默认</strong>(不写)：<strong>包访问权限</strong>，只能在该类和该类所在的包中被访问（部分隐藏）。</li><li><code>protected</code>：<strong>子类访问权限</strong>，只能在该类、该类所在的包及该类的子类中被访问（部分暴露）。</li><li><code>public</code>：<strong>公共访问权限</strong>，该类可以在任意地方来访问（彻底暴露）。</li></ul><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:center"><code>private</code></th><th style="text-align:center">默认</th><th style="text-align:center"><code>protected</code></th><th style="text-align:center"><code>public</code></th></tr></thead><tbody><tr class="odd"><td style="text-align:center">当前类</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr class="even"><td style="text-align:center">当前包</td><td style="text-align:center">❌</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr class="odd"><td style="text-align:center">子类</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr class="even"><td style="text-align:center">任意</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">✅</td></tr></tbody></table><h3 id="static">static</h3><p>有<code>static</code>的成员属于<strong>类成员</strong>，无<code>static</code>的成员属于<strong>实例成员</strong>。<code>static</code>只能修饰<strong>成员变量</strong>、<strong>方法</strong>、<strong>初始化块</strong>、<strong>内部类</strong>。</p><p>使用<code>static</code>修饰的成员，<strong>通常</strong>使用<code>类名.成员名</code>访问。</p><p>注意：</p><ul><li>Java 允许通过实例对象来访问<code>static</code>成员，但并<strong>不推荐</strong>这么做。</li><li><strong>非<code>static</code>成员可以访问<code>static</code>成员，相反，<code>static</code>成员不能调用非<code>static</code>成员。</strong></li></ul><h3 id="this">this</h3><h4 id="this-引用">this 引用</h4><p><code>this</code>可以出现在非<code>static</code>的<strong>方法</strong>、<strong>构造器</strong>中。用于代表当前正在使用的对象（谁调用他就代表谁）。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Flower</span> &#123;</span><br><span class="line">  String color;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Flower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&quot;yellow&quot;</span>; <span class="comment">// 创建对象时将颜色设置为 黄色</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;已修改&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&quot;red&quot;</span>;    <span class="comment">// 将当前对象的颜色修改为 红色</span></span><br><span class="line">    <span class="built_in">this</span>.output();         <span class="comment">// 调用当前对象中的 output 方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this-调用">this 调用</h4><p>可以通过<code>this(参数)</code>来调用该类的对应构造器，具体可见下方的<strong>构造器重载</strong>。</p><h3 id="super">super</h3><h4 id="super-限定">super 限定</h4><p>与<strong>this 引用</strong>类似，<code>super</code>用于限定访问父类的<strong>实例变量</strong>、<strong>实例方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Base中的foo方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sub中的foo重写方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(foo);       <span class="comment">// 200 (Sub类)</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>.foo);  <span class="comment">// 200 (Sub类)</span></span><br><span class="line">    System.out.println(<span class="built_in">super</span>.foo); <span class="comment">// 20 (Base类)</span></span><br><span class="line"></span><br><span class="line">    bar();        <span class="comment">// Sub中的foo重写方法 (Sub类)</span></span><br><span class="line">    <span class="built_in">this</span>.bar();   <span class="comment">// Sub中的foo重写方法 (Sub类)</span></span><br><span class="line">    <span class="built_in">super</span>.bar();  <span class="comment">// Base中的foo方法 (Base类)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用父类构造器">调用父类构造器</h4><p>与<strong>this 调用</strong>类似，用于调用父类构造器。</p><p>子类构造器<strong>一定</strong>要调用父类构造器<strong>一次</strong>。如果<strong>子类构造器</strong>没有显式调用<strong>父类构造器</strong>，系统将在<strong>子类构造器</strong>开头<strong>自动调用</strong>父类<strong>无参构造</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Fruit</span><span class="params">(<span class="type">double</span> weight)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(<span class="type">double</span> weight, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(weight);</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="final">final</h3><p><code>final</code>可以修饰<strong>变量</strong>（<strong>成员变量</strong>、<strong>局部变量</strong>）、<strong>方法</strong>、<strong>类</strong>。与<code>abstract</code>互斥。</p><h4 id="final修饰变量"><code>final</code>修饰变量</h4><p>当<code>final</code>修饰<strong>变量</strong>时，必须为该变量赋初始值，且<strong>无法重新赋值</strong>（对象可以进行修改）。</p><ul><li>当<code>final</code>修饰<strong>实例变量</strong>时，必须显式指定初始值，且只能在<strong>定义时</strong>、<strong>实例初始化块</strong>、<strong>各构造器</strong>其中的一个位置指定。</li><li>当<code>final</code>修饰<strong>类变量</strong>时，必须显式指定初始值，且只能在<strong>定义时</strong>、<strong>类初始化块</strong>其中的一个位置指定。</li></ul><h4 id="final的宏替换"><code>final</code>的宏替换</h4><p>当变量满足以下条件时，该变量出现的所有地方将会被替换成变量的值：</p><ul><li>变量有<code>final</code>修饰</li><li>声明时指定了初始值</li><li>变量初始值可在编译时确定</li></ul><img src="/archives/java-oop/16323961305864.jpg"><h4 id="final修饰方法"><code>final</code>修饰方法</h4><p><code>final</code>修饰方法指不允许被子类<strong>重写</strong>，避免该方法被子类破坏。</p><h4 id="final修饰类"><code>final</code>修饰类</h4><p><code>final</code>修饰类以后该类<strong>不允许</strong>派生子类。</p><h3 id="abstract">abstract</h3><p><code>abstract</code>只能修饰<strong>类</strong>和<strong>方法</strong>，且与<code>final</code>互斥。</p><h4 id="抽象类">抽象类</h4><p><strong>抽象类</strong>指使用<code>abstract</code>修饰的类，主要作用是<strong>派生子类</strong>。</p><p><strong>抽象类</strong>有以下特性：</p><ul><li>抽象类<strong>可以有</strong>抽象方法。</li><li>抽象类<strong>无法</strong>创建对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象方法">抽象方法</h4><p><strong>抽象方法</strong>指<strong>只有方法签名，无方法体</strong>的方法。<strong>抽象方法必须被子类重写，否则不能被调用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="comment">// 不能有方法体</span></span><br></pre></td></tr></table></figure><h2 id="面向对象三大特征">面向对象三大特征</h2><h3 id="封装">封装</h3><p>封装包含两方面含义：</p><ul><li><strong>隐藏</strong>：将内部实现细节隐藏</li><li><strong>暴露</strong>：通过暴露的接口来操作对象。</li></ul><p>封装的要求：<strong>合理隐藏，合理暴露。</strong></p><p>封装主要是通过<strong>访问控制修饰符</strong>来实现</p><p>在 Java 中，<strong>实例变量</strong>通常使用<code>private</code>来修饰，将其隐藏。并提供相应的<code>getter</code>、<code>setter</code>方法，来控制该成员变量的访问。</p><p>如下代码所示，<code>User</code>类中有一个成员变量（<code>name</code>），要求<code>name</code>的长度在 10 位以内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;名称长度必须在10位以内！&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承">继承</h3><p>继承最大好处是<strong>代码复用</strong>。</p><p>Java 中继承是<strong>类与类</strong>之间的关系（而非对象与对象之间的关系），是一种<strong>由一般到特殊</strong>的关系（如<strong>苹果类</strong>(<strong>子类</strong>、<strong>派生类</strong>)继承了<strong>水果类</strong>(<strong>父类</strong>、<strong>超类</strong>、<strong>基类</strong>)），<strong>子类的实例可以当作父类的实例来使用</strong>。</p><p>在 Java 中，<strong>继承</strong>通过如下语法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 子类名 extends 父类 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>Java 是单继承父类，只能有 <strong>1 个直接继承的父类</strong>。</li><li>如果不显式继承父类，Java 默认继承<code>Object</code>类。</li></ul><p>子类可以调用父类非<code>private</code>修饰的<strong>成员变量</strong>、<strong>方法</strong>（见上方<strong>访问控制</strong>表格）。</p><h3 id="多态">多态</h3><p><strong>多态</strong>是指同一个类型的多个实例，在执行同一个方法时，呈现出多种行为特征。</p><h4 id="变量的类型">变量的类型</h4><p><strong>编译时类型</strong>：声明该变量时指定的类型。在 Java 程序编译阶段，Java 编译器只认<strong>编译时类型</strong>。当调用子类有而父类没有的方法，且使用<strong>向上转型</strong>时，编译器将报错。</p><p><strong>运行时类型</strong>：该变量实际所引用的类型。</p><h4 id="向上转型">向上转型</h4><p>子类的对象可以直接赋值给父类变量，其可以自动完成。</p><p>例如，<strong>Ostrich 类</strong>继承了<strong>Bird 类</strong>，那么定义<strong>Ostrich</strong>实例时可以进行如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;飞咯~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不会飞呀~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Bird</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">    <span class="type">Bird</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ostrich</span>();</span><br><span class="line"></span><br><span class="line">    b1.fly();  <span class="comment">// 飞咯~</span></span><br><span class="line">    b2.fly();  <span class="comment">// 不会飞呀~</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向下转型-强制转换">向下转型 (强制转换)</h4><p>当使用<strong>向上转型</strong>特性时，想要调用子类方法时，需要强制转换成对应类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;飞咯~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;跑得快呢&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Bird</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ostrich</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1.run(); // 无法编译</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Ostrich</span> <span class="variable">b2</span> <span class="operator">=</span> (Ostrich) b1;</span><br><span class="line">    b2.run(); <span class="comment">// 正常编译</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>强转运算符只能在编译类型具有继承关系的变量之间进行强转，否则编译将会报错（如<code>String</code>类型强转成<code>Integer</code>）。</li><li>如果在编译类型具有继承关系的变量之间转换时，如果被转变量的实际类型不是要转换的目标类型，程序就会引发<code>ClassCastException</code>异常。</li></ul><h4 id="instanceof">instanceof</h4><p>为了避免<code>ClassCastException</code>异常，Java 提供了<code>instanceof</code>运算符。格式是<code>变量名 instanceof 类型</code>，当变量所引用的对象是后面类或子类的实例时，返回<code>true</code>。</p><p><strong>instanceof 只能在具有继承关系的变量之间进行强转，否则编译将会报错，故当变量与类之间没有关系时，也不会返回<code>false</code>。</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    <span class="keyword">if</span>(fruit <span class="keyword">instanceof</span> Apple) &#123;</span><br><span class="line">      <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> (Apple)fruit;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 Java 16 开始，instanceof 运算符得到了升级。见本文最后<strong>Java 16 增强的 instanceof</strong>。</p><h2 id="面向对象重点">面向对象重点</h2><h3 id="方法重载">方法重载</h3><p><strong>方法重载</strong>(<code>Overload</code>)指<strong>方法名相同，形参列表不同的方法</strong>。Java 通过参数类型来判断该方法是否为重载方法。<strong>修饰符不同或返回值类型不同的方法不能称为方法重载！</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;哦吼？&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;商品名：&quot;</span>+ name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;商品名：&quot;</span> + name + <span class="string">&quot;, 价格：&quot;</span> + price);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    show();            <span class="comment">// 哦吼？</span></span><br><span class="line">    show(<span class="string">&quot;手机&quot;</span>);       <span class="comment">// 商品名：手机</span></span><br><span class="line">    show(<span class="string">&quot;平板&quot;</span>, <span class="number">3000</span>); <span class="comment">// 商品名：平板, 价格：3000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器重载">构造器重载</h3><p><strong>构造器重载</strong>要求<strong>形参列表不同</strong>。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个问题，就是当需要为某个成员统一修改时，可能需要一一修改构造器。例如，需要在<code>name</code>成员前添加<code>Dog:</code>的前缀，需要一一修改构造器。</p><p>这里可以通过<code>this(参数)</code>来调用对应的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Dog: &quot;</span> + name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(name);  <span class="comment">// 调用 `public Dog(String)` 构造器</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重写">方法重写</h3><p><strong>方法重写</strong>(<code>Override</code>)是指<strong>子类</strong>将<strong>父类</strong>的方法重写。<strong>方法重写</strong>要求<strong>方法名、形参列表相同，返回值类型、声明抛出的异常相同或更小(即子类)，访问权限相同或更大</strong>。</p><p><strong>重写的方法</strong>通常使用<code>@Override</code>注解来修饰（<strong>避免重写错代码</strong>）。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;鸟飞咯&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;鸵鸟不会飞……&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tostring-与-equals-方法">toString 与 equals 方法</h3><p><code>toString</code>方法是将当前对象以<strong>文本的方式</strong>来表示出来，Java 默认的<code>toString</code>方法是<code>类名@哈希码</code>的格式，通常我们重写该方法将其内部的成员变量表示出来。</p><p><code>equals</code>方法则是用于比较两个对象是否相同，Java 默认通过比较两个引用变量是否指向同一个对象，通常我们重写该方法使用<strong>该类的关键属性</strong>来比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="comment">// 有参构造</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Getter / Setter 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// toString 方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person[name=&quot;</span> + name</span><br><span class="line">         + <span class="string">&quot;, age=&quot;</span> + age</span><br><span class="line">         + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// equals 方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 同一个对象</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == Person.class) &#123;</span><br><span class="line">      <span class="comment">// obj不为null且obj和当前对象的类相同</span></span><br><span class="line">      <span class="type">Person</span> <span class="variable">target</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(target.getName())</span><br><span class="line">             <span class="comment">// String类型需要使用equals方法比较</span></span><br><span class="line">          &amp;&amp; <span class="built_in">this</span>.age == target.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王强&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王强&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(p1);     <span class="comment">// Person[name=王强, age=18]</span></span><br><span class="line">    System.out.println(p2);     <span class="comment">// Person[name=王强, age=18]</span></span><br><span class="line">    System.out.println(p3.toString()); <span class="comment">// Person[name=张三, age=30]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1.equals(p2))          <span class="comment">// true</span></span><br><span class="line">      System.out.println(<span class="string">&quot;p1和p2是同一个人&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化块">初始化块</h3><p><strong>初始化块</strong>的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<strong>修饰符</strong>只能出现<code>static</code>，无<code>static</code>修饰的称为<strong>实例初始化块</strong>，有<code>static</code>修饰的称为<strong>类初始化块</strong>。</p><h4 id="实例初始化块">实例初始化块</h4><p><strong>实例初始化块</strong>实际上是「<strong>假象</strong>」，块中所有代码在<strong>编译</strong>时将会被<strong>还原到每个构造器的最前面</strong>。左图为编译前的原始代码，右图为<code>class</code>文件反编译的代码。</p><img src="/archives/java-oop/16322017907275.jpg"><p><strong>实例初始化块</strong>的作用是<strong>将各个构造器前相同的代码抽离到实例初始化块，从而实现代码复用</strong>。</p><h4 id="类初始化块">类初始化块</h4><p><strong>类初始化块</strong>负责对类进行初始化。当程序<strong>第一次主动使用</strong>(除了<strong>仅使用该类声明变量</strong>)该类时，系统会为该类分配内存空间，并调用类初始化块。程序运行时，该类初始化块只执行一次。</p><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:center">执行次数</th><th style="text-align:center">执行先后</th><th style="text-align:center">执行时间</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">类初始化块</td><td style="text-align:center">1 次</td><td style="text-align:center">先</td><td style="text-align:center">第一次<strong>主动</strong>使用该类</td></tr><tr class="even"><td style="text-align:center">实例初始化块</td><td style="text-align:center">N 次</td><td style="text-align:center">后</td><td style="text-align:center">每次调用构造器</td></tr></tbody></table><h3 id="抽象类-1">抽象类</h3><p>见上面<code>abstract</code>关键字</p><h3 id="接口">接口</h3><p><strong>接口</strong>相当于一个彻底抽象的类，体现<strong>一种规范</strong>。接口中所有东西都使用<code>public</code>修饰（通常省略）。接口支持多继承。</p><h4 id="接口定义">接口定义</h4><p>接口的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 [extends 父接口<span class="number">1</span>, 父接口<span class="number">2</span>, ...] &#123;</span><br><span class="line">  <span class="comment">// 成员变量（常量，自动使用`public static final`修饰）</span></span><br><span class="line">  <span class="comment">// 抽象方法：Java 8 后支持类方法、默认方法（带有方法体的抽象方法，与实例方法类似）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>修饰符</strong>只能为<code>public</code>。<strong>接口名</strong>命名规范基本与类名系统，通常使用形容词来定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="comment">// 反编译后：</span></span><br><span class="line">  <span class="comment">// public static final int MAX_WEIGHT = 100;</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">MAX_WEIGHT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;  <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java 8 后的类方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java 8 后的默认方法</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用接口">使用接口</h4><p>使用接口中<strong>成员变量</strong>、<strong>类方法</strong>时，与调用类成员相似，即<code>接口名.成员名</code>。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(MyInterface.MAX_WEIGHT); <span class="comment">// 100</span></span><br><span class="line">    MyInterface.staticMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口">实现接口</h4><p><strong>子类要么重写接口中所有抽象方法，要么定义为抽象类。</strong></p><p>实现接口的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 implements 父接口<span class="number">1</span> [, 父接口<span class="number">2</span>, ...] &#123;</span><br><span class="line">  <span class="comment">// 5大成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以实现上方的接口为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>private</code>方法本质是实例方法。</strong></p><h3 id="内部类">内部类</h3><p><strong>内部类</strong>是在类体中定义的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 外部类 &#123;</span><br><span class="line">  [修饰符] class 内部类 [extends 父类] [implements 接口] &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部类</strong>与<strong>外部类</strong>的区别如下：</p><ul><li><strong>内部类</strong>与<strong>外部类</strong>相比可使用<code>static</code>、<code>private</code>、<code>protected</code>修饰符。</li><li>非静态内部类<strong>不能</strong>拥有静态成员（<strong>常量除外</strong>）。</li><li>内部类可以直接访问外部类私有成员，但静态内部类不能访问外部类的非静态成员。</li></ul><p><strong>内部类的意义</strong>：当某个类的实例必须依附于另一个类存在时，可使用内部类。且内部类可以提供更好的封装（可使用<code>private</code>修饰）。</p><p>内部类生成的文件名格式为：<code>外部类$内部类.class</code></p><h4 id="内部类区分同名变量">内部类区分同名变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">      System.out.println(length);            <span class="comment">// 2000</span></span><br><span class="line">      System.out.println(<span class="built_in">this</span>.length);       <span class="comment">// 200</span></span><br><span class="line">      System.out.println(Foo.<span class="built_in">this</span>.length);   <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用内部类">使用内部类</h4><p><strong>（1）在外部类中使用内部类</strong></p><p>基本与使用其他类相同，需要注意的是<strong>静态成员不能使用非静态内部类创建实例</strong>。</p><p><strong>（2）在外部类的外面使用静态内部类</strong></p><p><strong>该内部类不能使用<code>private</code>修饰</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;我来自Foo.Bar.test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Foo.Bar.test();  <span class="comment">// 我来自Foo.Bar.test()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）在外部类的外面使用非静态内部类 (不常见)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;非静态内部类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    Foo.<span class="type">Bar</span> <span class="variable">fb</span> <span class="operator">=</span> foo.<span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"></span><br><span class="line">    fb.test(); <span class="comment">// 非静态内部类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部内部类">局部内部类</h4><p>定义在方法中的内部类，不常用，略。</p><h4 id="匿名内部类">匿名内部类</h4><p><strong>匿名内部类</strong>指没有名字的类，无法复用。</p><p>匿名内部类的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器(参数)|接口() &#123;</span><br><span class="line">  <span class="comment">// 除了构造器，其他都可以定义</span></span><br><span class="line">  <span class="comment">// 但一般只实现抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>匿名内部类必须显式继承父类，或实现一个接口。</li><li>匿名内部类不能是抽象类，因此必须实现抽象父类或接口中的所有抽象方法。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    foo.test();  <span class="comment">// 匿名内部类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举">枚举</h3><p><strong>枚举</strong>的定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="keyword">enum</span> 枚举名 &#123;</span><br><span class="line">  <span class="comment">// 第一行列出所有实例</span></span><br><span class="line">  <span class="comment">// 可以定义 5 大成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修饰符</strong>只能为<code>public</code>。</p><p>枚举类与普通类的区别：</p><ul><li><strong>枚举</strong>默认已经继承<code>Enum</code>类，无法继承其他类。</li><li><strong>枚举</strong>要么是<code>final</code>类，要么是<code>abstract</code>类。且 Java 会自动判断该类为<code>final</code>类还是<code>abstract</code>类。</li><li><strong>枚举</strong>要求在开头列出所有实例</li></ul><p><strong>枚举类</strong>默认拥有以下方法：</p><ul><li><code>static Weekday[] values()</code>: 返回所有枚举实例</li><li><code>static Weekday valueOf(String)</code>：根据枚举名返回枚举实例</li><li><code>String name()</code>：返回枚举实例的名称</li><li><code>int ordinal()</code>：返回枚举实例的序号</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT; <span class="comment">// 所有实例</span></span><br><span class="line"></span><br><span class="line">    Weekday() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我来自构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我来自枚举中的foo方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Weekday.WED);    <span class="comment">// WED</span></span><br><span class="line">        System.out.println(Arrays.toString(Weekday.values())); <span class="comment">// [SUN, MON, TUE, WED, THU, FRI, SAT]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">d1</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        System.out.println(d1.ordinal());   <span class="comment">// 0</span></span><br><span class="line">        System.out.println(d1.name());      <span class="comment">// SUN</span></span><br><span class="line">        d1.foo();  <span class="comment">// 我来自枚举中的foo方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">d2</span> <span class="operator">=</span> Weekday.valueOf(<span class="string">&quot;TUE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举与switch">枚举与<code>switch</code></h4><p><code>switch</code>语句可以与枚举共同使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> MON:</span><br><span class="line">            <span class="keyword">case</span> TUE:</span><br><span class="line">            <span class="keyword">case</span> WED:</span><br><span class="line">            <span class="keyword">case</span> THU:</span><br><span class="line">            <span class="keyword">case</span> FRI:</span><br><span class="line">                System.out.println(<span class="string">&quot;上班哦&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SAT:</span><br><span class="line">            <span class="keyword">case</span> SUN:</span><br><span class="line">                System.out.println(<span class="string">&quot;放假哦&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        day.info(); <span class="comment">// 放假哦</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类与构造器">枚举类与构造器</h4><p><strong>枚举</strong>定义后本质为<code>public static final</code>的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">  SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Weekday</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">SUN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">MON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">TUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">WED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">THU</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">FRI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">SAT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们可以自己手动编写构造器，其使用方式与正常类相似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">  SUN(<span class="literal">false</span>),</span><br><span class="line">  MON(<span class="literal">true</span>),</span><br><span class="line">  TUE(<span class="literal">true</span>),</span><br><span class="line">  WED(<span class="literal">true</span>),</span><br><span class="line">  THU(<span class="literal">true</span>),</span><br><span class="line">  FRI(<span class="literal">true</span>),</span><br><span class="line">  SAT(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isWorkday;</span><br><span class="line"></span><br><span class="line">  Weekday(<span class="type">boolean</span> isWorkday) &#123;  <span class="comment">// private 构造器</span></span><br><span class="line">    <span class="built_in">this</span>.isWorkday = isWorkday;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n-more-things">N More Things</h2><h3 id="记录类">记录类</h3><p><strong>记录类</strong>(<strong>Record</strong>)是从 Java 16 正式引入的类型( <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/395">JEP 395</a> )。记录类会自动地为其添加<strong>有参构造</strong>、<strong>Getter</strong>、<code>toString</code>、<code>equals</code>和<code>hashCode</code>方法。</p><p>在 Java 16 之前，定义一个纯数据类可能需要如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">other</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">    <span class="keyword">return</span> other.x == x &amp;&amp; other.y == y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(x, y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%d, y=%d]&quot;</span>, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而引入<code>Record</code>类以后，该类可以简化为如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>Record</code>类能做的事不止这些。具体可以阅读 <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/395">JEP 395</a> 。</p><h3 id="形参个数可变方法">形参个数可变方法</h3><p>在 Java 中，方法可以有<strong>可变长</strong>参数。该参数位于某一方法的最后一位。</p><p>例如，如下定义了一个<strong>形参个数可变方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... sites)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，定义了一个<code>String</code>类型的可变长参数。可变长参数本质上是一个<strong>数组</strong>。<strong>可变长参数只能位于形参列表的最后一位！</strong></p><p>该方法可以通过如下方式调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;GitHub&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Bing&quot;</span>&#125;) <span class="comment">// 方法 1</span></span><br><span class="line">test(<span class="string">&quot;GitHub&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Bing&quot;</span>)  <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure><p><strong>使用<code>Type...</code>和<code>Type[]</code>的区别：前者可以通过两种方法调用，后者只能由方法 1 调用</strong></p><h3 id="java-8-函数式编程">Java 8 函数式编程</h3><p>见 <a href="/archives/java-functional-program">Java 函数式编程知识整理</a> 。</p><h3 id="java-9-接口的-private-方法">Java 9 接口的 private 方法</h3><p>Java 8 中<code>default</code>方法本质是<strong>实例方法</strong>。在 Java 9 之前定义默认方法时，如果某些方法有公共部分，需要多次编写相同的代码。Java 9 以后，可以将重复的代码抽离出来，独立成<code>private</code>方法，同时实现隐藏。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PrivateMethod</span> &#123;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    common();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    common();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 工具方法只被本类默认方法使用，并不希望暴露出去</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">common</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;公共部分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-16-增强的-instanceof">Java 16 增强的 instanceof</h3><p>在 <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/394">JEP 394</a>中，<code>instanceof</code>运算符得到了升级。</p><p>从 Java 16 开始，可以通过<code>变量名 instanceof 类名 新变量名</code>判断该变量是否属于某个类的实例。如果属于，Java 将自动将其强制转换，并赋值到新的变量中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 16 之前</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 16 及以后</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Java 16 增强的 instanceof 功能远远不止这些。具体阅读 <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/394">JEP 394</a> 。</p><h2 id="参考资料">参考资料</h2><ul><li><a target="_blank" rel="noopener" href="https://union-click.jd.com/jdc?e=&amp;p=JF8BAMUJK1olXDYCV1pdAUoUB19MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksUB28BGlgRQl9HCANtdUpkA2twQgV1PE59KjxDcCNISg1pXVcZbQcyVF9cC04VBWsBHGslXQEyAjBdCUoWAm4NG14WbQcyVFlfC0oTAmYNGVoTWTYFVFdtUx55dQRLWCBQCXlcMgM9OHsnAF84K1slXjZAOlhYARtHBTtaHgsRXwNXA1cNC0hHBTwJGFkSDVJRB1ddOEkWAmsBKw">《疯狂 Java 讲义 · 第 5 版》</a></li><li><a target="_blank" rel="noopener" href="https://bfw.h5.xeknow.com/s/1YClVz">跟着李刚老师学 Java（视频）</a></li></ul></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Taoning Ge</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.gtn1024.me/archives/java-oop/" title="Java 面向对象知识详解">https://blog.gtn1024.me/archives/java-oop/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag"><i class="fa fa-tag"></i> 面向对象</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/bitwise-operation/" rel="prev" title="你一定看得懂的位运算"><i class="fa fa-angle-left"></i> 你一定看得懂的位运算</a></div><div class="post-nav-item"><a href="/archives/java-functional-program/" rel="next" title="Java 函数式编程详解">Java 函数式编程详解 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Taoning Ge</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a href="https://github.com/gtn1024" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>