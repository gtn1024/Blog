<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>菜狗学算法——基础知识</title>
    <url>/archives/algorithm-basic/</url>
    <content><![CDATA[<p><strong>算法</strong>（<strong>Algorithm</strong>）是用来解决问题的方法。对于相同的问题，使用不同的算法，可能得到的结果是相同的，但在其背后所消耗的资源（时间、空间）也许千差万别。</p>
<span id="more"></span>
<h2 id="二分查找">二分查找</h2>
<p>还记得 <a href="https://www.youtube.com/watch?v=YoXxevp1WRQ">CS50
撕书教授 David 撕电话薄的视频</a>吗？</p>
<img src="/archives/algorithm-basic/er-1.png" class="">
<img src="/archives/algorithm-basic/er-2.png" class="">
<p>在该视频中，David
想要在电话薄中查找自己的姓名。他每次将电话薄从中间撕开，判断其姓名首字母<code>D</code>在该页的前面还是后面，丢掉无用的部分。这段视频生动的展示了「<strong>二分查找</strong>(<strong>Binary
Search</strong>)」这种算法。</p>
<p>那么，<strong>二分查找</strong>究竟解决了什么痛点？</p>
<p>使用<strong>顺序查找</strong>(<strong>Linear
Search</strong>)时，我们可能从前往后找所需的一个数据。</p>
<p>仍然以电话簿为例。假如整本电话薄有 1024 页，你最多需要找 1024
次才能找到你所需要的姓名。</p>
<p>而使用<strong>二分查找</strong>时，你最多只需要寻找 <strong><span
class="math inline">\(log_2 1024 = 10\)</span></strong>
次就可以找到你所需要的姓名。</p>
<p>如上所示的两种查找方式的时间增长趋势如下图：</p>
<img src="/archives/algorithm-basic/%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%88%86%E5%A2%9E%E9%95%BF%E8%B6%8B%E5%8A%BF.png" class="">
<h2 id="运行时间">运行时间</h2>
<h3 id="大-o-表示法">大 <em>O</em> 表示法</h3>
<p><strong>运行时间</strong>(<strong>Running
time</strong>)指一个算法执行所用的时间。有许多方式可以代表<strong>运行时间</strong>，其中最为广泛的是「<strong>大_O_表示法</strong>」。它使用斜体的_O_来表示。<strong>大_O_表示法</strong>表示了一个算法最差的情况所需的运行时间。</p>
<p>上面所示的增长趋势用<strong>大_O_表示法</strong>可以为以下图像：</p>
<img src="/archives/algorithm-basic/BigO-1.png" class="">
<p>为了表示某一算法的增长趋势，通常我们会省略一些<strong>东西</strong>（例如<strong>系数</strong>、<strong>底数</strong>等），故以上图像可以再次优化：</p>
<img src="/archives/algorithm-basic/BigO-2.png" class="">
<p>下面列举几个常见的<strong>大_O_表示法</strong>的表现形式：</p>
<ul>
<li><strong><em>O</em>(<span
class="math inline">\(n^2\)</span>)</strong></li>
<li><strong><em>O</em>(n log n)</strong></li>
<li><strong><em>O</em>(n)</strong> (如<strong>顺序查找</strong>)</li>
<li><strong><em>O</em>(log n)</strong>
(如<strong>二分查找</strong>)</li>
<li><strong><em>O</em>(1)</strong></li>
</ul>
<h3 id="大-ωomega-表示法">大 <em>Ω</em>(<em>Omega</em>) 表示法</h3>
<p>与<strong>大_O_表示法</strong>相反，<strong>大 <em>Ω</em>
表示法</strong>表示了最好的情况。</p>
<p>下面列举几个常见的<strong>大_Ω_表示法</strong>的表现形式：</p>
<ul>
<li><strong><em>Ω</em>(<span
class="math inline">\(n^2\)</span>)</strong></li>
<li><strong><em>Ω</em>(n log n)</strong></li>
<li><strong><em>Ω</em>(n)</strong></li>
<li><strong><em>Ω</em>(log n)</strong></li>
<li><strong><em>Ω</em>(1)</strong>
(如<strong>顺序查找</strong>、<strong>二分查找</strong>)</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=YoXxevp1WRQ">CS50 2020
Letcure 0 - Scratch</a></li>
<li><a href="https://www.youtube.com/watch?v=gR6nycuZKlM">CS50 2020
Letcure 3 - Algorithms</a></li>
<li><a
href="https://union-click.jd.com/jdc?e=&amp;p=JF8BAMQJK1olXDYCV15YAUIVAF9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksUA2oBElkWQl9HCANtFilwXRpyTAN2AVJ7CUQ8Xi8TS2xbXVcZbQcyVF9cC04VBWsBHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfCUsTB2cPGl4TWTYFVFdtUx55dQRLWCBQCXlcMgM9OHsnAF84K1slXjZAOlpaARhHU2dfHFkTXgNXBgxVXx4QAjwAG1wSXwBRB1tbOEkWAmsB">《算法图解》</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法知识</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图论——拓扑排序</title>
    <url>/archives/algorithm-graph-topo/</url>
    <content><![CDATA[<p>在现实生活中，我们要做一系列的事情。而这些事情之间会存在顺序或依赖关系，即做一件事情之前，我们必须先做好另一件事。比如，在大学里学习的课程，通常都会有先后顺序。</p>
<span id="more"></span>
<img src="/archives/algorithm-graph-topo/topo.drawio.png" class="">
<p>图中，“高等数学”、“线性代数”是“离散数学”的先修课程，“离散数学”、“高级语言程序设计”是“数据结构”的先修课程，“高级语言程序设计”是“面向对象程序设计”的先修课程，“数据结构”、“高级语言程序设计”是“算法分析与设计”的先修课程。而“大学生心理健康”、“劳动教育”则作为独立的课程存在，不作为先修课程。</p>
<p>这张课程的关系图，我们可以将其课程名称由编号代替，进而形成一张图：</p>
<img src="/archives/algorithm-graph-topo/topo-nodes.drawio.png" class="">
<p>该图其中一个拓扑序列为
<code>1 3 5 6 2 4 7 8 9</code>。（这里之所以说是其中的一个拓扑序列，是因为一张图可以有多个拓扑序列）</p>
<p>继续使用课程举例，如果“课程1”依赖了“课程2”，“课程2”依赖了“课程3”，而“课程3”又依赖了课程“1”，那么无论如何我们都是无法学习的。</p>

<p>这种现象按照图论的说法称为“回路”。一个图有拓扑排序的条件是不能构成回路。因此，拓扑排序同时可以判断是否存在环。</p>
<h2 id="拓扑排序的概念">拓扑排序的概念</h2>
<p>拓扑排序是指在一个 <strong>有向无环图</strong>（DAG，Directed Acyclic
Graph）中，我们将定点以线性的方式进行排序，使得任意一对由 <span
class="math inline">\(u\)</span> 指向 <span
class="math inline">\(v\)</span> 的有向边 <span
class="math inline">\((u,v)\)</span>，都有 <span
class="math inline">\(u\)</span> 在 <span
class="math inline">\(v\)</span> 的前面。</p>
<p>拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。</p>
<h2 id="kahn-算法基于-bfs-的拓扑排序">Kahn 算法（基于 BFS
的拓扑排序）</h2>
<p>Kahn 算法是求解拓扑排序的一个十分常见的算法。其算法流程如下：</p>
<ol type="1">
<li>找到所有入度为 0
的点，放入队列。这些点没有先后关系，可任意输出。</li>
<li>弹出队头元素 <span class="math inline">\(t\)</span>，将 <span
class="math inline">\(t\)</span> 的所有邻接点的入度减
1。如果有的点入度为 0，则将其加入队列。</li>
<li>不断执行以上步骤，直至队列为空。如果队列为空后仍然有点没有入队，则该图不是一个
<strong>有向无环图</strong>，不存在拓扑排序。</li>
</ol>
<p>上面课程表的一个拓扑序列为
<code>1 -&gt; 3 -&gt; 5 -&gt; 6 -&gt; 2 -&gt; 4 -&gt; 7 -&gt; 8 -&gt; 9</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n + <span class="number">1</span>);  <span class="comment">// 邻接表</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ind</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;     <span class="comment">// 入度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    ind[v]++;</span><br><span class="line">    a[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ind[i]) &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ord</span><span class="params">(n)</span></span>;  <span class="comment">// 存储拓扑排序</span></span><br><span class="line">  <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> tt = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    ord[idx++] = tt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : a[tt]) &#123;</span><br><span class="line">      <span class="comment">// 为其邻接点入度减 1</span></span><br><span class="line">      ind[i]--;</span><br><span class="line">      <span class="keyword">if</span> (!ind[i]) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (idx != n) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Circle!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      cout &lt;&lt; ord[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法知识</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>图论——存储图</title>
    <url>/archives/algorithm-graph-make/</url>
    <content><![CDATA[<p>图论算法是一个很大的专题，有很多的知识点。但是，在学习图论的各个知识点之前，首先需要对于图的存储有十分清楚的理解，了解各种方式的优劣。</p>
<span id="more"></span>
<p>一般而言，图的存储方式有 4 种：</p>
<ul>
<li>直接存边</li>
<li>邻接矩阵</li>
<li>邻接表</li>
<li>链式前向星</li>
</ul>
<h2 id="直接存边">直接存边</h2>
<p>在某些算法中（如用于解决最小生成树问题的 Kruskal
算法），我们可以直接将边存在一个结构体中。这种方式的优势是编码快速，空间效率高，并且便于依据边权进行排序。</p>
<p>结构体的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> u;  <span class="comment">// 起点</span></span><br><span class="line">  <span class="type">int</span> v;  <span class="comment">// 终点</span></span><br><span class="line">  <span class="type">int</span> w;  <span class="comment">// 边权</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>u</th>
<th>v</th>
<th>w</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="even">
<td>1</td>
<td>2</td>
<td>5</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>4</td>
</tr>
<tr class="even">
<td>2</td>
<td>6</td>
<td>8</td>
</tr>
<tr class="odd">
<td>4</td>
<td>5</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>建立上表中图并排序的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">edges.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>&#125;);</span><br><span class="line">edges.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;);</span><br><span class="line">edges.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>&#125;);</span><br><span class="line">edges.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>&#125;);</span><br><span class="line">edges.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [&amp;](Edge a, Edge b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (Edge &amp;edge : edges) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, edge.u, edge.v, edge.w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 5 9</span></span><br><span class="line"><span class="comment">// 2 6 8</span></span><br><span class="line"><span class="comment">// 1 2 5</span></span><br><span class="line"><span class="comment">// 2 1 4</span></span><br><span class="line"><span class="comment">// 0 1 3</span></span><br></pre></td></tr></table></figure>
<h2 id="邻接矩阵">邻接矩阵</h2>
<p>邻接矩阵是 3 种存储方式中最为简单的方式。本方式使用一个二维数组
<code>g[N][N]</code> 进行图的存储。</p>
<p>其中，<code>g[i][j] = w</code> 代表点 i 至点 j 存在一条边权为 w
的有向边。当然，如果仅仅想表示 i 和 j 之间有边，可以将 w
定为任何值。一般而言，如果使用邻接矩阵表示边权时，通常使得该邻接矩阵所有元素的初始值为
<code>INF</code>（<strong>一个十分大的数字</strong>）；使用邻接矩阵表示有边时，可以直接将该邻接矩阵定义为
<strong>二维布尔数组</strong>。</p>
<p>使用邻接矩阵的空间复杂度为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p><strong>注意</strong>：无向图是特殊的有向图。节点 i 至节点 j
有一条无向边代表节点 i 和节点 j 之间，以及节点 j 和节点 i
之间分别有条有向边。</p>
<p>例如，一个 1000 个节点的图，点的编号从 1 开始，可以为该邻接矩阵定义为
<code>g[1001][1001]</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;    <span class="comment">// 使用 INF 代表一个十分大的数字</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_direct</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  g[u][v] = <span class="built_in">min</span>(g[u][v], w);   <span class="comment">// 如果有重边，则将其赋值为较小的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_undirect</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  g[u][v] = g[v][u] = <span class="built_in">min</span>(g[u][v], w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));  <span class="comment">// 使用 memset 将 g 数组所有元素赋为极大值</span></span><br><span class="line">  <span class="built_in">add_direct</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">30</span>);    <span class="comment">// 添加一条 100 -&gt; 200 的有向边，边权为 30</span></span><br><span class="line">  <span class="built_in">add_undirect</span>(<span class="number">500</span>, <span class="number">600</span>, <span class="number">80</span>);  <span class="comment">// 添加一条 500 &lt;-&gt; 600 的无向边，边权为 80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>邻接矩阵优点</strong>：</p>
<ul>
<li>编程简单；</li>
<li>查找快速，复杂度仅为 <span
class="math inline">\(O(1)\)</span>；</li>
<li>十分适合稠密图；</li>
</ul>
<p><strong>邻接矩阵缺点</strong>：</p>
<ul>
<li>不适合稀疏图。当使用邻接矩阵表示稀疏图时，会有大片的空间浪费；</li>
<li>不能够存储重边。</li>
</ul>
<h2 id="邻接表">邻接表</h2>
<p>为了解决邻接矩阵浪费空间的问题，可以使用邻接表。邻接表是一个类似于链表的结构。邻接表的空间复杂度为
<span class="math inline">\(O(n+m)\)</span>。</p>
<p>例如，一个节点个数为 7 的有向图，可以有如下边：</p>
<table>
<thead>
<tr class="header">
<th>u</th>
<th>v</th>
<th>w</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="even">
<td>1</td>
<td>2</td>
<td>5</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>4</td>
</tr>
<tr class="even">
<td>2</td>
<td>6</td>
<td>8</td>
</tr>
<tr class="odd">
<td>4</td>
<td>5</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>其实现后效果可以如下图所示：</p>
<img src="/archives/algorithm-graph-make/20230719225543.png" class="">
<p>使用 STL 中的 <code>vector</code> 容器实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; e[N];  <span class="comment">// 使用 vector 数组下标代表 u</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  e[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; e[u].<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历所有由 u 开始的边</span></span><br><span class="line">    <span class="keyword">if</span> (e[u][i].v == v) &#123;</span><br><span class="line">      <span class="keyword">return</span> e[u][i].w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;    <span class="comment">// 找不到，则输出个极大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">add_edge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">add_edge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">add_edge</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">add_edge</span>(<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">add_edge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> w1 = <span class="built_in">find</span>(<span class="number">1</span>, <span class="number">4</span>);  <span class="comment">// 找不到边，返回 0x3f3f3f3f</span></span><br><span class="line">  <span class="type">int</span> w2 = <span class="built_in">find</span>(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 找到该边，返回 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式前向星">链式前向星</h2>
<p>链式前向星是空间效率最高的存储方式。其使用静态数组来存储边，来模拟邻接表。</p>
<p>链式前向星使用 <code>head[N]</code> 来确定头节点，使用
<code>edges[M]</code> 来表示边。边的类型是个结构体，其中包括
<code>to</code>（指向的边）、<code>nxt</code>（下一条边）、<code>w</code>（边权）。</p>
<p>依然使用上面邻接表的例子。使用链式前向星，其空间存储如下图所示：</p>
<img src="/archives/algorithm-graph-make/20230719233809.png" class="">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="comment">// 最多有 100,000 条边</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e6</span> + <span class="number">10</span>; <span class="comment">// 最多有 1,000,000 条边</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> to, nxt, w;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"><span class="type">int</span> head[N], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  edges[cnt].to = v;        <span class="comment">// 指向 v 点</span></span><br><span class="line">  edges[cnt].w = w;         <span class="comment">// 边权为 w</span></span><br><span class="line">  edges[cnt].nxt = head[u]; <span class="comment">// 将 u 的邻接点向后顺延</span></span><br><span class="line">  head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123; <span class="comment">// ~i 相当于 i != -1</span></span><br><span class="line">    <span class="keyword">if</span> (edges[i].to == v) &#123;</span><br><span class="line">      <span class="keyword">return</span> edges[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="built_in">add</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> w1 = <span class="built_in">find</span>(<span class="number">1</span>, <span class="number">4</span>);  <span class="comment">// 找不到边，返回 0x3f3f3f3f</span></span><br><span class="line">  <span class="type">int</span> w2 = <span class="built_in">find</span>(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 找到该边，返回 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法知识</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>菜狗学算法——排序</title>
    <url>/archives/algorithm-sort/</url>
    <content><![CDATA[<p>排序在生活中随处可见，在程序中也是如此。</p>
<span id="more"></span>
<p>例如按照身高排序：</p>
<img src="/archives/algorithm-sort/%E8%BA%AB%E9%AB%98%E6%8E%92%E5%88%97.png" class="">
<p>再例如你在购买商品时的顺序：</p>
<img src="/archives/algorithm-sort/16302493019615.jpg" class="">
<p>下面将讲解几个比较常见的排序算法。</p>
<p>注意：在计算机中，对一组数据排序需要一个一个「<strong>看</strong>」里面的数据。就类似一组数据在一个「<strong>箱子</strong>」中，我们必须将箱子打开才能知道里面的数据。</p>
<img src="/archives/algorithm-sort/%E7%AE%B1%E5%AD%90%E5%8E%9F%E5%88%99.png" class="">
<h2 id="选择排序-selection-sort">选择排序 (Selection Sort)</h2>
<p><strong>选择排序</strong>（<strong>Selection
sort</strong>）是一种简单直观的排序算法。</p>
<p>它的工作原理如下：</p>
<ol type="1">
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<h3 id="例子">例子</h3>
<p>首先给出一组数：</p>
<img src="/archives/algorithm-sort/%E5%8E%9F%E5%A7%8B%E6%8E%92%E5%BA%8F.png" class="">
<p><strong>选择排序</strong>开始，首先算法开始遍历整个数组，从左往右找最小的数，并且将当前找到的最小数记录下来。当遍历到最后一个数字<code>1</code>时，将
<code>1</code>
和数组中<code>0</code>号元素（<code>6</code>）交换位置。将1做出标记，表示它已经到达正确的位置，不再进行排序。</p>
<img src="/archives/algorithm-sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F1.png" class="">
<p>后面的元素以类似的方法进行排序。</p>
<p>排序的动画如图所示：</p>
<img src="/archives/algorithm-sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" class="">
<img src="/archives/algorithm-sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F2.gif" class="">
<h3 id="代码实现">代码实现</h3>
<p><strong>选择排序</strong>对应的简易 Java 代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != min) &#123;</span><br><span class="line">                <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">                array[i] = array[min];</span><br><span class="line">                array[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时间">运行时间</h3>
<p><strong>选择排序</strong>算法共有 <span
class="math inline">\(n+(n-1)+(n-2)+...+2+1\)</span> (即 <span
class="math inline">\(n^2/2 + n/2\)</span>
)步，通过<strong>大<em>O</em>表示法</strong>表示为<strong><em>O</em>(<span
class="math inline">\(n^2\)</span>)</strong>。</p>
<h2 id="冒泡排序-bubble-sort">冒泡排序 (Bubble Sort)</h2>
<p><strong>冒泡排序</strong>（<strong>Bubble
Sort</strong>）是一种简单的排序算法。</p>
<p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h3 id="例子-1">例子</h3>
<p>首先给出一组数：</p>
<img src="/archives/algorithm-sort/%E5%8E%9F%E5%A7%8B%E6%8E%92%E5%BA%8F.png" class="">
<p><strong>冒泡排序</strong>开始，首先将 0 号元素和 1
号元素进行比较，如果 0 号元素大于 1
号元素，则将这两个元素位置对调。依此类推。</p>
<img src="/archives/algorithm-sort/%E5%86%92%E6%B3%A1%E8%BF%87%E7%A8%8B.png" class="">
<p>排序的动画如图所示：</p>
<img src="/archives/algorithm-sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" class="">
<img src="/archives/algorithm-sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F2.gif" class="">
<h3 id="代码实现-1">代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时间-1">运行时间</h3>
<p><strong>冒泡排序</strong>算法共有 <span
class="math inline">\((n-1)*(n-1)\)</span> (即 <span
class="math inline">\(n^2 - 2n + 1\)</span>
)步，通过<strong>大<em>O</em>表示法</strong>表示为<strong><em>O</em>(<span
class="math inline">\(n^2\)</span>)</strong>。</p>
<h2 id="归并排序-merge-sort">归并排序 (Merge Sort)</h2>
<p><strong>归并排序</strong>（<strong>Merge
Sort</strong>）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide
and
Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
<h3 id="例子-2">例子</h3>
<img src="/archives/algorithm-sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" class="">
<img src="/archives/algorithm-sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.gif" class="">
<h2
id="大o表示法性能分析"><strong>大<em>O</em>表示法</strong>性能分析</h2>
<p>以上三种排序的对比可以见 <a
href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">这个视频</a>
，国内搬运： <a
href="https://www.bilibili.com/video/BV1ex411e7eb">Bilibili</a> 。</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>算法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>O</em>(<span class="math inline">\(n^2\)</span>)</td>
<td>选择排序、冒泡排序</td>
</tr>
<tr class="even">
<td><em>O</em>(<span class="math inline">\(nlogn\)</span>)</td>
<td>归并排序</td>
</tr>
<tr class="odd">
<td><em>O</em>(<span class="math inline">\(n\)</span>)</td>
<td>顺序查找</td>
</tr>
<tr class="even">
<td><em>O</em>(<span class="math inline">\(logn\)</span>)</td>
<td>二分查找</td>
</tr>
<tr class="odd">
<td><em>O</em>(<span class="math inline">\(1\)</span>)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Selection_sort">维基百科 -
选择排序</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bubble_sort">维基百科 -
冒泡排序</a></li>
<li><a href="https://en.wikipedia.org/wiki/Merge_sort">维基百科 -
归并排序</a></li>
<li><a
href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Comparison
Sorting Algorithms</a></li>
<li><a href="https://www.youtube.com/watch?v=gR6nycuZKlM">CS50 2020
Letcure 3 - Algorithms</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法知识</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>你一定看得懂的位运算</title>
    <url>/archives/bitwise-operation/</url>
    <content><![CDATA[<p><strong>位运算</strong>是直接对整数在内存中的二进制位进行操作。</p>
<span id="more"></span>
<p>阅读本章时，可以打开计算机上的计算器，并将其设置为<strong>程序员模式</strong>。</p>
<img src="/archives/bitwise-operation/16306388392067.jpg" class="">
<h2 id="了解位">了解位</h2>
<p>在计算机内部，数据以<strong>二进制</strong>来存储，每一个<strong>二进制数</strong>称为一个<strong>位</strong>(<strong>Bit</strong>)。</p>
<h2 id="位运算">位运算</h2>
<p><strong>位运算</strong>通常有如下几个操作：</p>
<ul>
<li>位与(&amp;, and)，当两位同时为 1 时才返回 1。</li>
<li>位或(|, or)，只要有一位为 1 就返回 1。</li>
<li>异或(^, xor)，当两位相同时返回 0，不相同时返回 1。</li>
<li>位非(~,
not)，将操作数的每个位（包括<strong>符号位</strong>）全部取反。</li>
<li>左移(&lt;&lt;, lsh)</li>
<li>右移(&gt;&gt;, rsh)</li>
</ul>
<p>其中，Java
语言还多一个<strong>无符号右移</strong>(&gt;&gt;&gt;)。</p>
<p><strong>位与</strong>、<strong>位或</strong>、<strong>异或</strong>的运算法则如下：</p>
<table>
<tbody>
<tr class="odd">
<td>操作数 1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>操作数 2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="odd">
<td>位与</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>位或</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>异或</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="位与">位与</h3>
<p>举个例子，<code>5 &amp; 9 = 1</code>，为什么呢？</p>
<p>首先将这两个数转换成二进制</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5: 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">9: 0000 0000 0000 0000 0000 0000 0000 1001</span><br><span class="line">------------------------------------------</span><br><span class="line">&amp;: 0000 0000 0000 0000 0000 0000 0000 0001 = 1</span><br></pre></td></tr></table></figure>
<h3 id="位或">位或</h3>
<p><code>5 | 9 = 13</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5: 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">9: 0000 0000 0000 0000 0000 0000 0000 1001</span><br><span class="line">------------------------------------------</span><br><span class="line">|: 0000 0000 0000 0000 0000 0000 0000 1101 = 13</span><br></pre></td></tr></table></figure>
<h3 id="异或">异或</h3>
<p><code>5 ^ 9 = 12</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5: 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">9: 0000 0000 0000 0000 0000 0000 0000 1001</span><br><span class="line">------------------------------------------</span><br><span class="line">^: 0000 0000 0000 0000 0000 0000 0000 1100 = 12</span><br></pre></td></tr></table></figure>
<h3 id="位非">位非</h3>
<p><code>~-5 = 4</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> -5: 1111 1111 1111 1111 1111 1111 1111 1011 (计算机内部负数以补码形式表示)</span><br><span class="line">~-5: 0000 0000 0000 0000 0000 0000 0000 0100</span><br></pre></td></tr></table></figure>
<h3 id="左移">左移</h3>
<p><strong>左移</strong>是将操作数二进制码整体向左移动制定的位数，左移后右边空出来的地方用
<code>0</code> 来填充。</p>
<p><code>5&lt;&lt;2 = 20</code>，<code>-5&lt;&lt;2 = -20</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">      5:    0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">   5&lt;&lt;2: 00 0000 0000 0000 0000 0000 0000 0001 0100</span><br><span class="line">-&gt;          0000 0000 0000 0000 0000 0000 0001 0100 = 20</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">     -5:    1111 1111 1111 1111 1111 1111 1111 1011</span><br><span class="line">  -5&lt;&lt;2: 11 1111 1111 1111 1111 1111 1111 1110 1100</span><br><span class="line">-&gt;          1111 1111 1111 1111 1111 1111 1110 1100 = -20</span><br></pre></td></tr></table></figure>
<h3 id="右移">右移</h3>
<p><strong>右移</strong>是将操作数的二进制码向右移动指定位数，右移后左边空出来的地方以原来的符号为来填充。若原来为正数，则在左边补
0，若为负数，则补 1。</p>
<p><code>5&gt;&gt;2 = 1</code>，<code>-5&gt;&gt;2 = -2</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">     5: 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">  5&gt;&gt;2:   00 0000 0000 0000 0000 0000 0000 0001 01</span><br><span class="line">-&gt;      0000 0000 0000 0000 0000 0000 0000 0001    = 1</span><br><span class="line">------------------------------------------------------</span><br><span class="line">    -5: 1111 1111 1111 1111 1111 1111 1111 1011</span><br><span class="line"> -5&gt;&gt;2:   11 1111 1111 1111 1111 1111 1111 1110 11</span><br><span class="line">-&gt;      1111 1111 1111 1111 1111 1111 1111 1110    = -2</span><br></pre></td></tr></table></figure>
<h3 id="java-中的无符号右移">Java 中的无符号右移</h3>
<p>与<strong>右移</strong>不同，<strong>无符号右移</strong>无论操作数为正数还是负数都将在左侧补
0。</p>
<p><code>-5&gt;&gt;&gt;2 = 1073741822</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">     -5: 1111 1111 1111 1111 1111 1111 1111 1011</span><br><span class="line"> -5&gt;&gt;&gt;2:   11 1111 1111 1111 1111 1111 1111 1110 11</span><br><span class="line">-&gt;       0011 1111 1111 1111 1111 1111 1111 1110    = 1073741822</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="https://union-click.jd.com/jdc?e=&amp;p=JF8BAM4JK1olXgALUV9YC04TAl8IGVodXAULV24ZVxNJXF9RXh5UHw0cSgYYXBcIWDoXSQVJQwYAVVZcC0IUHDZNRwYlOVsHFhoOYSJ0BBl1QQ9VGl90CDVZeEcbM244G1oUXgMAUlpUD3snA2g4TTUVXAcDVV9YCE4UM244G1wXXAEGXVxaDk8SBl8PG1IlBlNsIjUeSzBSVxBWfQZ1bTYyV25tOEsnAF9KdQkdVFIAUwsICh8RVmpdHV9FDwNXXApVCEhFBm4IHg4VbQQDVVpUOA">疯狂
Java 讲义</a></li>
</ul>
]]></content>
      <categories>
        <category>知识科普</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 退役指南</title>
    <url>/archives/codeforces-retire-note/</url>
    <content><![CDATA[<p>退役了，整点啥活呢？</p>
<span id="more"></span>
<p>不如把 Codeforces 往负分打吧！</p>
<img src="/archives/codeforces-retire-note/cf.png" class="">
<p>每场只给 A 交一发样例，然后下号！</p>
<img src="/archives/codeforces-retire-note/cf2.png" class="">
]]></content>
  </entry>
  <entry>
    <title>「深入理解计算机系统」学习笔记（第一章）</title>
    <url>/archives/csapp-1/</url>
    <content><![CDATA[<p>本文主要是《深入理解计算机系统》第一章（计算机系统漫游）的学习笔记。主要依据
B 站 UP 主九曲阑干对 CSAPP 的 <a
href="https://www.bilibili.com/video/BV1cD4y1D7uR">中文讲解</a>。</p>
<p>CSDIY 上对于本课程的介绍：<a
href="https://csdiy.wiki/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CSAPP"
class="uri">https://csdiy.wiki/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CSAPP</a></p>
<span id="more"></span>
<h2 id="程序的生命周期">程序的生命周期</h2>
<p>本章主要是依据一个普通 Hello World
程序的生命周期，对计算机系统主要概念做一个概述。</p>
<p>一个程序大体上分为如下四个步骤：</p>
<ol type="1">
<li>创建 Create</li>
<li>编译 Compile</li>
<li>运行 Run</li>
<li>退出 Exit</li>
</ol>
<p>首先，创建一个 C 语言程序，命名为 <code>hello.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 GCC 对程序进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -o hello.exe hello.c</span><br></pre></td></tr></table></figure>
<p>通过本命令，编写的 <code>hello.c</code>
通过编译系统进行编译后，生成名为 <code>hello.exe</code>
的可执行程序。</p>
<img src="/archives/csapp-1/compile-abs.drawio.png" class="">
<p>虽然我们只通过了一条命令就完成了程序的编译，但事实上编译过程是很复杂的。</p>
<p>一个编译过程主要分为四部分：</p>
<ol type="1">
<li>预处理 Pre-processing (cpp)：经过预处理器将 <code>hello.c</code>
转变为 <code>hello.i</code> 文件。</li>
<li>编译 Compile
(cc1)：通过词法分析、语法分析、语义分析、中间代码生成、优化等一系列操作，将
<code>hello.i</code> 转变为 <code>hello.s</code> 文件。</li>
<li>汇编 Assemble
(as)：汇编器根据指令集翻译为机器指令，并且按照固定规则进行打包。将
<code>hello.s</code> 转变为可重定位目标文件 <code>hello.o</code>。</li>
<li>链接 Link (ld)：链接器将 <code>hello.o</code>
与其他库文件链接，生成可执行文件 <code>hello.exe</code>。</li>
</ol>
<img src="/archives/csapp-1/compile-process.drawio.png" class="">
<h2 id="理解编译系统过程的意义">理解编译系统过程的意义</h2>
<p>为什么要理解编译系统是如何工作的？</p>
<ol type="1">
<li>优化程序性能</li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞</li>
</ol>
<h2 id="通过-shell-运行程序">通过 Shell 运行程序</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./hello.exe</span><br><span class="line">hello, world!</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="计算机系统的硬件组成">计算机系统的硬件组成</h2>
<img src="/archives/csapp-1/hardware.png" class="">
<h2 id="高速缓存">高速缓存</h2>
<p>在通常情况下，大容量的存储设备的存取速度要比小容量的慢，运行速度更快的设备的价格相对于低速设备要更贵。</p>
<p>例如，在一个系统上，磁盘容量一般为 TB 级，内存容量一般为 GB
级，而寄存器文件的容量一般为 B 级别。</p>
<p>对于处理器而言，从磁盘上读取一个字所花费的时间开销比从内存中读取的开销大
1000 万倍；从寄存器文件读取数据比从内存读取数据快 100
倍。随着半导体技术的发展，处理器与内存之间的差距还在持续增大。</p>
<p>针对处理器和内存的差异，系统设计人员在寄存器和内存之间引入了了高速缓存（cache）。比较强的处理器一般有三级缓存，分别是
L1、L2 和 L3，从前往后容量逐渐变大，速度逐渐变慢。L1
与寄存器之间的速度差异不大，容量为 KB 级别；L2 与 L3
容量更大一些，分别为 MB 级别。</p>
<img src="/archives/csapp-1/cache.png" class="">
<h2 id="操作系统">操作系统</h2>
<p>操作系统是应用程序和硬件之间的中间层，所有应用程序对硬件的操作都需要经过操作系统进行完成。</p>
<img src="/archives/csapp-1/os.png" class="">
<p>操作系统引入几个概念：</p>
<ol type="1">
<li>文件 Files：对于 I/O 设备的抽象</li>
<li>虚拟内存 Virtual memory：对于内存和磁盘 I/O 的抽象</li>
<li>进程 Processes：对处理器、内存和 I/O 设备的抽象</li>
</ol>
<img src="/archives/csapp-1/os-abs.png" class="">
<h2 id="虚拟机">虚拟机</h2>
<p>虚拟机是对于整个计算机系统的抽象，包括操作系统、处理器、内存、I/O
设备。</p>
<img src="/archives/csapp-1/vm.png" class="">
]]></content>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>「深入理解计算机系统」学习笔记（第二章）</title>
    <url>/archives/csapp-2/</url>
    <content><![CDATA[<p>本文主要是《深入理解计算机系统》第二章（信息的表示和处理）的学习笔记。主要依据
B 站 UP 主九曲阑干对 CSAPP 的 <a
href="https://www.bilibili.com/video/BV1cD4y1D7uR">中文讲解</a>。</p>
<p>本章主要涉及如下知识点：</p>
<ol type="1">
<li>信息存储</li>
<li>整数表示</li>
<li>整数运算</li>
<li>浮点数</li>
</ol>
<span id="more"></span>
<h2 id="信息存储">信息存储</h2>
<p>在计算机中，内存可以视为一个大数组，数组的元素由一个个字节组成。每一个字节都由一个唯一的数字表示，称为地址。地址的集合称为
<strong>虚拟地址空间</strong>。</p>
<img src="/archives/csapp-2/vap.png" class="">
<h3 id="字节">字节</h3>
<p>一个字节是由 8 个位组成，一个位的取值只为 0 或 1。</p>
<table>
<thead>
<tr class="header">
<th>二进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>00000000</code></td>
<td><code>0</code></td>
</tr>
<tr class="even">
<td><code>11111111</code></td>
<td><code>255</code></td>
</tr>
</tbody>
</table>
<p>我们将使用二进制表示数字的方式称为 <strong>位模式</strong>。</p>
<h3 id="十六进制">十六进制</h3>
<p>因为使用二进制表示比较冗长，而十进制与二进制之间的转换较为麻烦。所以引入了十六进制。</p>
<p>十六进制使用 10 个数字（<code>0123456789</code>）和 6
个字母（<code>ABCDEF</code>）表示。</p>
<p>在 C 语言中，使用 <code>0x</code> 开头表示一个十六进制。</p>
<table>
<thead>
<tr class="header">
<th>十进制</th>
<th>十六进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0000</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0001</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>0010</td>
</tr>
<tr class="even">
<td>3</td>
<td>3</td>
<td>0011</td>
</tr>
<tr class="odd">
<td>4</td>
<td>4</td>
<td>0100</td>
</tr>
<tr class="even">
<td>5</td>
<td>5</td>
<td>0101</td>
</tr>
<tr class="odd">
<td>6</td>
<td>6</td>
<td>0110</td>
</tr>
<tr class="even">
<td>7</td>
<td>7</td>
<td>0111</td>
</tr>
<tr class="odd">
<td>8</td>
<td>8</td>
<td>1000</td>
</tr>
<tr class="even">
<td>9</td>
<td>9</td>
<td>1001</td>
</tr>
<tr class="odd">
<td>10</td>
<td>A</td>
<td>1010</td>
</tr>
<tr class="even">
<td>11</td>
<td>B</td>
<td>1011</td>
</tr>
<tr class="odd">
<td>12</td>
<td>C</td>
<td>1100</td>
</tr>
<tr class="even">
<td>13</td>
<td>D</td>
<td>1101</td>
</tr>
<tr class="odd">
<td>14</td>
<td>E</td>
<td>1110</td>
</tr>
<tr class="even">
<td>15</td>
<td>F</td>
<td>1111</td>
</tr>
</tbody>
</table>
<h3 id="字长">字长</h3>
<p>字长决定了虚拟地址空间最大值。</p>
<table>
<thead>
<tr class="header">
<th>字长</th>
<th>虚拟地址空间</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>w 位</td>
<td>0 ~ <span class="math inline">\(2^w-1\)</span></td>
<td></td>
</tr>
<tr class="even">
<td>32 位</td>
<td>0 ~ <span class="math inline">\(2^{32}-1\)</span></td>
<td>4GB</td>
</tr>
<tr class="odd">
<td>64 位</td>
<td>0 ~ <span class="math inline">\(2^{64}-1\)</span></td>
<td>16EB</td>
</tr>
</tbody>
</table>
<p>C 语言各个数据类型大小如下表所示：</p>
<img src="/archives/csapp-2/type.png" class="">
<h3 id="地址和字节排布">地址和字节排布</h3>
<img src="/archives/csapp-2/order.png" class="">
<p>目前，大部分使用的 PC 机使用小端法排布。</p>
<h3 id="字符串表示">字符串表示</h3>
<p>C 语言中字符串被定义为以 NULL 结束的字符数组。例如，字符串
<code>abcde</code> 虽然只有 5 个字符，但长度为 6。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;abcde&quot;</span>;</span><br></pre></td></tr></table></figure>
<img src="/archives/csapp-2/string.png" class="">
<p>NULL 在 C 语言中对应
<code>0x00</code>，该字符串在内存中以十六进制表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">61  62  63  64  65  00</span><br></pre></td></tr></table></figure>
<h3 id="c-语言的位级运算">C 语言的位级运算</h3>
<p>逻辑非：</p>
<table>
<thead>
<tr class="header">
<th>~</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>逻辑与：</p>
<table>
<thead>
<tr class="header">
<th>&amp;</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>逻辑或：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th></th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>逻辑异或：</p>
<table>
<thead>
<tr class="header">
<th>^</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="c-语言的逻辑运算">C 语言的逻辑运算</h3>
<p>逻辑运算中，所有非 0 都表示 true，0 表示 false。</p>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>结果</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x41</td>
<td>0x00</td>
<td></td>
</tr>
<tr class="even">
<td>!0x00</td>
<td>0x01</td>
<td></td>
</tr>
<tr class="odd">
<td>!!0x41</td>
<td>0x01</td>
<td></td>
</tr>
<tr class="even">
<td>0x69 &amp;&amp; 0x55</td>
<td>0x01</td>
<td></td>
</tr>
<tr class="odd">
<td>0x69</td>
<td></td>
<td>0x55</td>
</tr>
<tr class="even">
<td>a &amp;&amp; 5 / a</td>
<td></td>
<td>当 a 为 0 时，不继续判断 5 / a</td>
</tr>
</tbody>
</table>
<h3 id="c-语言的移位运算">C 语言的移位运算</h3>
<p>对于二进制数 <code>01100011</code>，</p>
<p>左移一位：<code>11000110</code></p>
<p>左移两位：<code>10001100</code></p>
<p>逻辑右移丢弃最右端 n 位，并在最左端补 n 个 0。</p>
<p>算术右移当最高位为 0 时，右移且在最左端补 0；最高位为 1
时，在最左端补 1。</p>
<p>大部分编译器对于有符号数采用算术右移，对于无符号数采用逻辑右移。</p>
<h2 id="整数表示">整数表示</h2>
<p>C 语言支持多种整型数据类型，以 64 位操作系统为例。</p>
<table>
<thead>
<tr class="header">
<th>C 数据类型</th>
<th>最小</th>
<th>最大</th>
<th>字节</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>char</code></td>
<td><span class="math inline">\(-2^7\)</span></td>
<td><span class="math inline">\(2^7-1\)</span></td>
<td>1</td>
</tr>
<tr class="even">
<td><code>unsigned char</code></td>
<td>0</td>
<td><span class="math inline">\(2^8-1\)</span></td>
<td>1</td>
</tr>
<tr class="odd">
<td><code>short</code></td>
<td><span class="math inline">\(-2^{15}\)</span></td>
<td><span class="math inline">\(2^{15}-1\)</span></td>
<td>2</td>
</tr>
<tr class="even">
<td><code>unsigned short</code></td>
<td>0</td>
<td><span class="math inline">\(2^{16}-1\)</span></td>
<td>2</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td><span class="math inline">\(-2^{31}\)</span></td>
<td><span class="math inline">\(2^{31}-1\)</span></td>
<td>4</td>
</tr>
<tr class="even">
<td><code>unsigned int</code></td>
<td>0</td>
<td><span class="math inline">\(2^{32}-1\)</span></td>
<td>4</td>
</tr>
<tr class="odd">
<td><code>long</code></td>
<td><span class="math inline">\(-2^{63}\)</span></td>
<td><span class="math inline">\(2^{63}-1\)</span></td>
<td>8</td>
</tr>
<tr class="even">
<td><code>unsigned long</code></td>
<td>0</td>
<td><span class="math inline">\(2^{64}-1\)</span></td>
<td>8</td>
</tr>
<tr class="odd">
<td><code>int32_t</code></td>
<td><span class="math inline">\(-2^{31}\)</span></td>
<td><span class="math inline">\(2^{31}-1\)</span></td>
<td>4</td>
</tr>
<tr class="even">
<td><code>uint32_t</code></td>
<td>0</td>
<td><span class="math inline">\(2^{32}-1\)</span></td>
<td>4</td>
</tr>
<tr class="odd">
<td><code>int64_t</code></td>
<td><span class="math inline">\(-2^{63}\)</span></td>
<td><span class="math inline">\(2^{63}-1\)</span></td>
<td>8</td>
</tr>
<tr class="even">
<td><code>uint64_t</code></td>
<td>0</td>
<td><span class="math inline">\(2^{64}-1\)</span></td>
<td>8</td>
</tr>
</tbody>
</table>
<p>需要特别注意，<code>long</code> 类型取值范围与机器字长有关。在 32
位机器上，<code>long</code> 为 4 字节；在 64 位机器上，<code>long</code>
为 8 字节。</p>
<h3 id="无符号数编码">无符号数编码</h3>
<p>对于向量 <span class="math inline">\(x = [x_{w-1}, x_{w-2}, \cdots,
x_1, x_0]\)</span>，</p>
<p><span class="math inline">\(B2U_w(x) = x_{w-1}\cdot 2^{w-1} +
x_{w-2}\cdot 2^{w-2} + \cdots + x_1\cdot 2^1 + x_0\cdot 2^0 =
\sum^{w-1}_{i=0}{x_i2^i}\)</span></p>
<h3 id="补码编码">补码编码</h3>
<p>对于向量 <span class="math inline">\(x = [x_{w-1}, x_{w-2}, \cdots,
x_1, x_0]\)</span>，</p>
<p><span class="math inline">\(B2T_w(x) = x_{w-1}\cdot -2^{w-1} +
x_{w-2}\cdot 2^{w-2} + \cdots + x_1\cdot 2^1 + x_0\cdot 2^0 =
-x_{w-1}\cdot 2^{w-1} + \sum^{w-2}_{i=0}{x_i2^i}\)</span></p>
]]></content>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>菜狗学数据结构——数组和链表</title>
    <url>/archives/data-structure-array-linkedlist/</url>
    <content><![CDATA[<p>数据结构的存储方式只有两种：<strong>数组</strong>和<strong>链表</strong>，这两个是其他数据结构实现的基础。</p>
<span id="more"></span>
<p>在编写程序的过程中，我们常常需要「找到」一个位置来存放「中间数据」。此时，我们常常定义<strong>变量</strong>来存储他们。当创建变量时，计算机会为其创建一个单独的「空间」来存放特定类型的数据。</p>
<p>如下所示，我们创建了一个<code>score</code>变量来存放一位同学的成绩。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure>
<p>计算机会在内存中单独开辟一片空间来存放数据，并且告诉程序相应的内存地址。如图所示，该变量的内存地址是<code>0x00000005</code>。</p>
<img src="/archives/data-structure-array-linkedlist/%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98.png" class="">
<p>当我们需要存储多个相同类型的数据时，似乎使用变量就显得不太「靠谱」了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">score1</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">score2</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">score3</span> <span class="operator">=</span> <span class="number">59</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">score4</span> <span class="operator">=</span> <span class="number">66</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">score5</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">score6</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">score7</span> <span class="operator">=</span> <span class="number">55</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">score8</span> <span class="operator">=</span> <span class="number">73</span>;</span><br></pre></td></tr></table></figure>
<p>如果有 200 个学生，难不成定义 200
个变量来存储学生成绩？这时可以使用<strong>数组</strong>和<strong>链表</strong>来存储。</p>
<h2 id="数组">数组</h2>
<p>使用数组时，计算机会在内存中开辟一整段连续的空间用于存放数据。依然以学生成绩为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">scores</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">80</span>, <span class="number">90</span>, <span class="number">59</span>, <span class="number">66</span>, <span class="number">11</span>, <span class="number">99</span>, <span class="number">55</span>, <span class="number">73</span>&#125;;</span><br></pre></td></tr></table></figure>
<img src="/archives/data-structure-array-linkedlist/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98.png" class="">
<p>如图所示，计算机为学生成绩分别开辟了 8 份空间用来分别存放 8
位学生的考试成绩。然而这里又出现了一个问题，如果想要添加第 9
位学生成绩时会怎么样？</p>
<p>答案就是，计算机会重新在内存中找一份空间用于存放这 9
位学生成绩。这也是为什么数组一旦创建就不可变。</p>
<h3 id="数组的操作">数组的操作</h3>
<p>在数组中，针对一个元素的位置有一个专业术语称为<strong>索引</strong>（又称<strong>下标</strong>）。我们通常通过<strong>索引</strong>（<strong>下标</strong>）来获取、修改数组元素</p>
<img src="/archives/data-structure-array-linkedlist/%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95.png" class="">
<p>数组的<strong>索引</strong>由 0
开始，最大值为<code>数组元素总数 - 1</code>。</p>
<h4 id="数组元素数据的获取">数组元素数据的获取</h4>
<p>数组元素数据通过<code>数组名[索引]</code>来获取。如以下代码展示了如何遍历一个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">scores</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">80</span>, <span class="number">90</span>, <span class="number">59</span>, <span class="number">66</span>, <span class="number">11</span>, <span class="number">99</span>, <span class="number">55</span>, <span class="number">73</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; scores.length; i++)&#123;</span><br><span class="line">    System.out.println(scores[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组元素数据的修改">数组元素数据的修改</h4>
<p>数组元素数据可以通过<code>数组名[索引] = 新数据</code>来修改。如以下代码展示了将<code>scores</code>数组中第
4 号元素（<code>11</code>分）修改为<code>81</code>分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">scores</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">80</span>, <span class="number">90</span>, <span class="number">59</span>, <span class="number">66</span>, <span class="number">11</span>, <span class="number">99</span>, <span class="number">55</span>, <span class="number">73</span>&#125;;</span><br><span class="line">scores[<span class="number">4</span>] = <span class="number">81</span>;</span><br></pre></td></tr></table></figure>
<h4 id="数组元素的插入">数组元素的插入</h4>
<p>如果需要在数组之间的某个位置插入一个元素，则需要将其后面的元素整体向后挪一位。当数组空间不足时，你需要重新创建一个空间来存放新的数组。</p>
<img src="/archives/data-structure-array-linkedlist/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5.png" class="">
<h4 id="数组元素的删除">数组元素的删除</h4>
<p>数组中一个元素删除时，通常使得其右边的元素向左挪一位。</p>
<img src="/archives/data-structure-array-linkedlist/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4.png" class="">
<h2 id="链表">链表</h2>
<p>与<strong>数组</strong>不同，<strong>链表</strong>中的<strong>元素</strong>可以在任意的内存位置中。</p>
<p>依然以上面的学生成绩为例，其在内存中如图所示。</p>
<img src="/archives/data-structure-array-linkedlist/%E9%93%BE%E8%A1%A8%E5%86%85%E5%AD%98.png" class="">
<p>一个简易链表的实现如下：</p>
<h3 id="链表的操作">链表的操作</h3>
<p>在链表中，我们通常将元素称为一个<strong>节点</strong>(<strong>node</strong>)，一个节点保存了其<strong>上下节点</strong>的地址。</p>
<p>通常节点的设计如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/archives/data-structure-array-linkedlist/%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.png" class="">
<h4 id="链表元素数据的获取">链表元素数据的获取</h4>
<p>在链表中，一个元素数据需要由上一个元素逐步向下寻找。具体代码实现可以参照下面的<code>get(int index)</code>方法。</p>
<h4 id="链表元素数据的修改">链表元素数据的修改</h4>
<p>在链表中，想要修改一个元素的数据首先要找到该元素，然后对其进行修改。具体代码实现可以参照下面的<code>update(int index, int newData)</code>方法。</p>
<h4 id="链表元素的插入">链表元素的插入</h4>
<p>在链表中，想要插入一个元素可以将上一个节点的<code>next</code>对象以及下一个节点的<code>prev</code>对象指向新的元素。具体代码实现可以参照下面的<code>insert(int index, int data)</code>方法。</p>
<h4 id="链表元素的删除">链表元素的删除</h4>
<p>在链表中，想要删除一个元素只需要确保没有任何一个元素指向该节点即可。具体代码实现可以参照下面的<code>remove(int index)</code>方法。</p>
<h3 id="简易链表的实现">简易链表的实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头节点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾节点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表实际长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表插入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data  插入元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 插入位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表节点范围！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">insertedNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        insertedNode.prev = last;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 空链表</span></span><br><span class="line">            head = insertedNode;</span><br><span class="line">            last = insertedNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 插入头部</span></span><br><span class="line">            insertedNode.next = head;</span><br><span class="line">            head = insertedNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == index) &#123;</span><br><span class="line">            <span class="comment">// 插入尾部</span></span><br><span class="line">            last.next = insertedNode;</span><br><span class="line">            last = insertedNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入中间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">var</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">            insertedNode.next = prevNode.next;</span><br><span class="line">            prevNode.next = insertedNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改数据元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index    修改元素索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newData  修改值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表节点范围！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> get(index);</span><br><span class="line">        node.data = newData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表删除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 删除位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表节点范围！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removedNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            removedNode = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">var</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">            removedNode = prevNode.next;</span><br><span class="line">            prevNode.next = <span class="literal">null</span>;</span><br><span class="line">            last = prevNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除中间节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">var</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">var</span> <span class="variable">nextNode</span> <span class="operator">=</span> prevNode.next.next;</span><br><span class="line">            removedNode = prevNode.next;</span><br><span class="line">            nextNode.prev = prevNode;</span><br><span class="line">            prevNode.next = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> removedNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表查找元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 查找位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表节点范围！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(temp.data);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> data) &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">myLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        myLinkedList.insert(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        myLinkedList.output();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        myLinkedList.update(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">        myLinkedList.remove(<span class="number">0</span>);</span><br><span class="line">        myLinkedList.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组和链表的优劣">数组和链表的优劣</h2>
<p>如下是<strong>数组</strong>和<strong>链表</strong>操作运行所需的时间：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读取</td>
<td><code>O(1)</code></td>
<td><code>O(n)</code></td>
</tr>
<tr class="even">
<td>插入</td>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr class="odd">
<td>删除</td>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="https://union-click.jd.com/jdc?e=&amp;p=JF8BAMQJK1olXDYCV15YAUIVAF9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksUA2oBElkWQl9HCANtFilwXRpyTAN2AVJ7CUQ8Xi8TS2xbXVcZbQcyVF9cC04VBWsBHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfCUsTB2cPGl4TWTYFVFdtUx55dQRLWCBQCXlcMgM9OHsnAF84K1slXjZAOlpaARhHU2dfHFkTXgNXBgxVXx4QAjwAG1wSXwBRB1tbOEkWAmsB">《算法图解》</a></li>
<li><a
href="https://union-click.jd.com/jdc?e=&amp;p=JF8BAMQJK1olXDYCV1pdCk0TA19MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksUB28KHV8VQl9HCANtQDt-V2dwXyt2LVZGMQsHDB8UWmlOXVcZbQcyVF9cC04VBWsBHGslXQEyAjBdCUoWAm4NG14WbQcyVFleAE0eB2gLElIRXzYFVFdtUx55dQRLWCBQCXlcMgM9OHsnAF84K1slXjZAOlxbXB5HCzhaGl4SDwMBB15UCx4TC2kMT1lADw9RUVwIOEkWAmsB">《漫画算法：小灰的算法之旅》</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法知识</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>菜狗学数据结构——栈和队列</title>
    <url>/archives/data-structure-stack-queue/</url>
    <content><![CDATA[<p>栈和队列是十分基础的数据结构，分别实现了 <strong>FILO</strong> 和
<strong>FIFO</strong> 两种数据处理方式。</p>
<span id="more"></span>
<h2 id="栈-stack">栈 (Stack)</h2>
<p><strong>栈</strong>(<strong>Stack</strong>)是一种线性的数据结构，栈中的元素遵循<strong>先入后出</strong>(<strong>FILO</strong>，First
In Last
Out)的原则。最早进入栈的元素位置称为<strong>栈底</strong>，最后进入站的元素位置成为<strong>栈顶</strong>。</p>
<img src="/archives/data-structure-stack-queue/%E6%A0%882.png" class="">
<h3 id="操作栈">操作栈</h3>
<img src="/archives/data-structure-stack-queue/%E6%A0%88.png" class="">
<h4 id="入栈-push">入栈 (push)</h4>
<p><strong>入栈</strong>(<strong>push</strong>)是将一个新的元素放入栈中，新元素的位置称为<strong>栈顶</strong>。</p>
<h4 id="出栈-pop">出栈 (pop)</h4>
<p><strong>出栈</strong>(<strong>pop</strong>)是将栈顶的元素从栈中弹出，原栈顶前一个元素位置成为新的<strong>栈顶</strong>。</p>
<h4 id="代码实现">代码实现</h4>
<p>使用<strong>数组</strong>实现栈的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyArrayStack</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= arr.length) arr = Arrays.copyOf(arr, <span class="number">2</span> * arr.length);</span><br><span class="line">        arr[size] = data;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        arr[size - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyArrayStack</span>(<span class="number">6</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">5</span>);</span><br><span class="line">        stack.push(<span class="number">6</span>);</span><br><span class="line">        stack.push(<span class="number">7</span>);</span><br><span class="line">        stack.push(<span class="number">8</span>);</span><br><span class="line">        stack.output();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>链表</strong>实现栈的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 空链表</span></span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.prev = last;</span><br><span class="line">            last.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        last = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">prevNode</span> <span class="operator">=</span> last.prev;</span><br><span class="line">        prevNode.next = <span class="literal">null</span>;</span><br><span class="line">        last = prevNode;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.print(temp.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> data) &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLinkedStack</span>();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">5</span>);</span><br><span class="line">        stack.push(<span class="number">6</span>);</span><br><span class="line">        stack.push(<span class="number">7</span>);</span><br><span class="line">        stack.push(<span class="number">8</span>);</span><br><span class="line">        stack.output();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行<strong>入栈</strong>、<strong>出栈</strong>操作的时间复杂度均为<code>O(1)</code>。</p>
<h2 id="队列-queue">队列 (Queue)</h2>
<p><strong>队列</strong>(<strong>Queue</strong>)也是一种线性数据结构，队列中的元素遵循<strong>先入先出</strong>(<strong>FIFO</strong>，First
In First
Out)的原则。队列的出口端称为<strong>队头</strong>，入口端称为<strong>队尾</strong>。</p>
<img src="/archives/data-structure-stack-queue/%E9%98%9F%E5%88%97.png" class="">
<h3 id="操作队列">操作队列</h3>
<h4 id="入队-enqueue">入队 (enqueue)</h4>
<p><strong>入队</strong>(<strong>enqueue</strong>)是将新的元素放入队列中，新元素下一个位置成为新的队尾。</p>
<h4 id="出队-dequeue">出队 (dequeue)</h4>
<p><strong>出队</strong>(<strong>dequeue</strong>)是将队头的元素移出队列，出队元素的后一个元素成为新的队头。</p>
<h4 id="代码实现-1">代码实现</h4>
<p>使用<strong>数组</strong>与<strong>链表</strong>实现队列的方式有所不同。</p>
<h5 id="数组实现">数组实现</h5>
<p>在不考虑扩容的情况下，队列的<strong>容量</strong>(<strong>capacity</strong>)是有限的，不断出队会使得队头前的空间逐渐失去作用。此时我们可以使用<strong>循环队列</strong>来保证队列容量的恒定，即使用已经出队的空间，来存放新的元素。</p>
<p>当<code>(队尾下标 + 1) % 数组长度 = 队头下标</code>时，表明该队列已满。（可结合单步调试进行理解）</p>
<img src="/archives/data-structure-stack-queue/%E9%98%9F%E5%88%972.png" class="">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyArrayQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 入队的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> element)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear + <span class="number">1</span>) % array.length == front)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        array[rear] = element;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (rear == front) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;队列已空&quot;</span>);</span><br><span class="line">        front = (front + <span class="number">1</span>) % array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i != rear; i = (i + <span class="number">1</span>) % array.length) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyArrayQueue</span>(<span class="number">5</span>);</span><br><span class="line">        queue.enQueue(<span class="number">1</span>);</span><br><span class="line">        queue.enQueue(<span class="number">2</span>);</span><br><span class="line">        queue.enQueue(<span class="number">3</span>);</span><br><span class="line">        queue.enQueue(<span class="number">4</span>);</span><br><span class="line">        queue.deQueue();</span><br><span class="line">        queue.deQueue();</span><br><span class="line">        queue.enQueue(<span class="number">5</span>);</span><br><span class="line">        queue.enQueue(<span class="number">6</span>);</span><br><span class="line">        queue.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>循环队列</strong>的意义在于，其不仅<strong>充分利用了数组的空间</strong>，还<strong>避免了数组元素移动带来的性能损失</strong>。其入队与出队的时间复杂度为<code>O(1)</code></p>
<h5 id="链表实现">链表实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 空队列</span></span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = newNode;</span><br><span class="line">            newNode.prev = last;</span><br><span class="line">        &#125;</span><br><span class="line">        last = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">nextNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        nextNode.prev = <span class="literal">null</span>;</span><br><span class="line">        head = nextNode;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(temp.data);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLinkedQueue</span>();</span><br><span class="line">        queue.enQueue(<span class="number">1</span>);</span><br><span class="line">        queue.enQueue(<span class="number">2</span>);</span><br><span class="line">        queue.enQueue(<span class="number">3</span>);</span><br><span class="line">        queue.enQueue(<span class="number">4</span>);</span><br><span class="line">        queue.deQueue();</span><br><span class="line">        queue.deQueue();</span><br><span class="line">        queue.enQueue(<span class="number">5</span>);</span><br><span class="line">        queue.enQueue(<span class="number">6</span>);</span><br><span class="line">        queue.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="https://union-click.jd.com/jdc?e=&amp;p=JF8BAMQJK1olXDYCV1pdCk0TA19MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksUB28KHV8VQl9HCANtQDt-V2dwXyt2LVZGMQsHDB8UWmlOXVcZbQcyVF9cC04VBWsBHGslXQEyAjBdCUoWAm4NG14WbQcyVFleAE0eB2gLElIRXzYFVFdtUx55dQRLWCBQCXlcMgM9OHsnAF84K1slXjZAOlxbXB5HCzhaGl4SDwMBB15UCx4TC2kMT1lADw9RUVwIOEkWAmsB">《漫画算法：小灰的算法之旅》</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法知识</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言入门 —— 数据结构</title>
    <url>/archives/go-basic-data-struct/</url>
    <content><![CDATA[<p>本文主要介绍 Go 语言中的一些基本的数据结构。</p>
<span id="more"></span>
<h2 id="数组">数组</h2>
<p>与其他语言类似，Go 语言的数组是长度不可变的。数组的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[长度]数据类型</span><br></pre></td></tr></table></figure>
<p>如下为数组的定义及赋值操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"> a[i] = i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义数组的时候，可以为数组赋初始值。此时，当数组元素确定时，数组的长度可以自动推导出来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">c := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切片">切片</h2>
<p>Go
语言中的切片（slice）就相当于其他编程语言中可以自动扩容的动态数组，如
C++ 中的 <code>vector</code>、Java 中的 <code>ArrayList</code> 等。</p>
<p>定义切片的语法如下：<code>make(切片类型, 长度, 容量)</code>。其中，容量可以省略，如果被省略，则容量和切片的长度一致。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slc1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(slc1, <span class="built_in">len</span>(slc1), <span class="built_in">cap</span>(slc1))</span><br><span class="line"><span class="comment">// [0 0 0] 3 3</span></span><br><span class="line"></span><br><span class="line">slc2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(slc2, <span class="built_in">len</span>(slc2), <span class="built_in">cap</span>(slc2))</span><br><span class="line"><span class="comment">// [0 0 0] 3 5</span></span><br></pre></td></tr></table></figure>
<h3 id="添加元素">添加元素</h3>
<p>在切片的末尾添加元素，可以使用 <code>append</code>
函数进行操作。<code>append</code>
函数在添加元素时，会自动根据切片的容量对切片进行扩容。同时，函数将返回新的切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, s) <span class="comment">// [1 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="获取切片某一范围">获取切片某一范围</h3>
<p>在 Go 语言中，如果需要获取切片的某个范围，可以使用
<code>s[a : b]</code>
的语法。其取出来的范围区间是左闭右开（<code>[a, b)</code>，即
<code>b</code> 取不到）的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;...)</span><br><span class="line">fmt.Println(s) <span class="comment">// [1 2 3 4 5 6 7 8 9 10]</span></span><br><span class="line"></span><br><span class="line">fmt.Println(s[<span class="number">1</span>:<span class="number">6</span>]) <span class="comment">// [2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>
<h2 id="哈希">哈希</h2>
<p>在 Go 语言中，定义哈希的格式是 <code>map[K]V</code>，其中
<code>K</code> 为 key 的类型，<code>V</code> 为 value
的类型。如下演示了两种哈希的定义方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hsh1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line"> <span class="string">&quot;one&quot;</span>:   <span class="number">1</span>,</span><br><span class="line"> <span class="string">&quot;two&quot;</span>:   <span class="number">2</span>,</span><br><span class="line"> <span class="string">&quot;three&quot;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">hsh1[<span class="string">&quot;four&quot;</span>] = <span class="number">4</span></span><br><span class="line">fmt.Println(hsh1[<span class="string">&quot;one&quot;</span>]) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">hsh2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">hsh2[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果需要删除一个 key，可以直接使用 <code>delete</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(hsh1, <span class="string">&quot;two&quot;</span>)</span><br><span class="line">fmt.Println(hsh1[<span class="string">&quot;two&quot;</span>]) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="range"><code>range</code></h2>
<p>在 <a href="/archives/go-basic-syntax/">上一篇</a> 中，已经提了
<code>for-range</code> 循环。<code>range</code>
可以迭代容器中的元素。对于数组、切片等类型，其返回元素所在的下标以及元素值。对于哈希，其返回
key 和 value。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;i = %v, v = %v\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i = 0, v = 1</span></span><br><span class="line"><span class="comment">// i = 1, v = 2</span></span><br><span class="line"><span class="comment">// i = 2, v = 3</span></span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line"> <span class="string">&quot;one&quot;</span>:   <span class="number">1</span>,</span><br><span class="line"> <span class="string">&quot;two&quot;</span>:   <span class="number">2</span>,</span><br><span class="line"> <span class="string">&quot;three&quot;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;k = %v, v = %v\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// k = one, v = 1</span></span><br><span class="line"><span class="comment">// k = two, v = 2</span></span><br><span class="line"><span class="comment">// k = three, v = 3</span></span><br></pre></td></tr></table></figure>
<h2 id="结构体">结构体</h2>
<p>Go 语言中，定义结构体的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名 <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="comment">// 成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下为结构体最基本使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line"> x <span class="type">int</span></span><br><span class="line"> y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">p1 := Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">p2 := Point&#123;x: <span class="number">2</span>, y: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1) <span class="comment">// main.Point&#123;x:1, y:1&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p2) <span class="comment">// main.Point&#123;x:2, y:2&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言入门 —— 基础语法</title>
    <url>/archives/go-basic-syntax/</url>
    <content><![CDATA[<p>本文主要对于 Go 语言的类型系统、变量常量及流程控制进行介绍。</p>
<span id="more"></span>
<h2 id="类型系统">类型系统</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<p>在 Go 语言中，有如下的基本数据类型：</p>
<ul>
<li><code>bool</code>：表示布尔类型，值为 <code>true</code> 或
<code>false</code>。</li>
<li><code>int8</code>、<code>uint8</code>、<code>int16</code>、<code>uint16</code>、<code>int32</code>、<code>uint32</code>、<code>int64</code>、<code>uint64</code>：整数类型，最后的数字代表有多少位，以
<code>u</code> 开头的为无符号整型。</li>
<li><code>int</code>、<code>uint</code>、<code>uintptr</code>：整数类型，类型的大小由编译器决定。保证
<code>uintptr</code> 类型能够存下一个内存地址。</li>
<li><code>float32</code>、<code>float64</code>：浮点型。</li>
<li><code>complex64</code>、<code>complex128</code>：复数类型，对应的实部和虚部数据类型相同。分别为
<code>float32</code> 和 <code>float64</code>。</li>
<li><code>string</code>：字符串类型。</li>
</ul>
<p>另外，Go 语言中 <code>byte</code> 和 <code>rune</code> 类型分别为
<code>uint8</code> 和 <code>int32</code> 的类型别名。</p>
<h3 id="类型别名">类型别名</h3>
<p>在 Go 语言中，可以通过 <code>type 类型名 = 类型</code>
来定义一个类型别名，这两个类型是等价的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Id = <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id1 Id = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> id2 <span class="type">uint64</span> = <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v %#v&quot;</span>, id1, id2) <span class="comment">// 0x1 0x1</span></span><br></pre></td></tr></table></figure>
<h2 id="变量与常量">变量与常量</h2>
<p>在 Go 语言中，定义一个变量有 2 种方式。</p>
<ol type="1">
<li>使用 <code>var</code> 关键字定义变量。</li>
<li>使用 <code>:=</code> 运算符定义变量。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span> <span class="comment">// 使用 var 定义变量</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>     <span class="comment">// 使用 var 定义变量，自动推导类型</span></span><br><span class="line">c := <span class="number">30</span>        <span class="comment">// 使用 := 定义变量，自动推导类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a = 10, b = 20, c = 30/</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a = %#v, b = %#v, c = %#v&quot;</span>, a, b, c)</span><br></pre></td></tr></table></figure>
<p>常量的定义更简单，直接使用 <code>const</code>
关键字即可定义常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> d <span class="type">int</span> = <span class="number">40</span> <span class="comment">// 使用 const 定义常量</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">50</span>     <span class="comment">// 使用 const 定义常量，自动推导类型</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;d = %#v, e = %#v&quot;</span>, d, e) <span class="comment">// d = 40, e = 50</span></span><br></pre></td></tr></table></figure>
<h2 id="流程控制">流程控制</h2>
<h3 id="条件语句">条件语句</h3>
<p>在 Go 语言中，主要有如下几种条件语句：</p>
<ul>
<li><code>if-else</code> 条件分支结构</li>
<li><code>switch-case</code> 分支结构</li>
</ul>
<p><code>if-else</code> 结构与其他编程语言相类似，但是 Go
语言的条件并不需要添加括号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">30</span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;大于30&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">20</span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;大于20&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">10</span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;大于10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;小于等于10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch-case</code> 语句也类似，但 <code>case</code>
后可以紧接多个值，并且对于条件较为灵活。同时，在 <code>switch</code>
中不需要添加 <code>break</code> 语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">20</span>, <span class="number">10</span>:</span><br><span class="line"> fmt.Println(<span class="string">&quot;a 是 10 或 20&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line"> fmt.Println(<span class="string">&quot;a 是 30&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"> fmt.Println(<span class="string">&quot;a 是其他数字&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> a &gt;= <span class="number">10</span>:</span><br><span class="line"> fmt.Println(<span class="string">&quot;a 大于等于 10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"> fmt.Println(<span class="string">&quot;a 小于 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环语句">循环语句</h3>
<p>不同于其他编程语言，Go 语言对于循环只有 <code>for</code>
一个关键字。同时，Go 语言的 <code>for</code>
关键字十分强大，可以实现传统编程语言的
<code>for</code>、<code>while</code> 等功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> a &lt;= <span class="number">20</span> &#123;</span><br><span class="line"> <span class="comment">// 相当于 while (a&lt;=20)</span></span><br><span class="line"> fmt.Println(a)</span><br><span class="line"> a++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"> <span class="comment">// 无限循环，相当于 while (true)</span></span><br><span class="line"> b++</span><br><span class="line"> <span class="keyword">if</span> b == <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与其他语言类似，Go 语言传统 <code>for</code>
循环语法中任意部分都可以省略。如下代码为等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ; ; &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;&#125;  <span class="comment">// 一般使用这种形式</span></span><br></pre></td></tr></table></figure>
<p>另外，Go 语言有一种 <code>for-range</code>
循环。其可以用于遍历容器。</p>
<p>如下为遍历数组的用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;正在遍历第 %v 个元素，值为 %v\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正在遍历第 0 个元素，值为 1</span></span><br><span class="line"><span class="comment">// 正在遍历第 1 个元素，值为 2</span></span><br><span class="line"><span class="comment">// 正在遍历第 2 个元素，值为 3</span></span><br></pre></td></tr></table></figure>
<p>遍历一个哈希表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mp := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line"> <span class="string">&quot;one&quot;</span>:   <span class="number">1</span>,</span><br><span class="line"> <span class="string">&quot;two&quot;</span>:   <span class="number">2</span>,</span><br><span class="line"> <span class="string">&quot;three&quot;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> mp &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;k = %v, v = %v\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// k = three, v = 3</span></span><br><span class="line"><span class="comment">// k = one, v = 1</span></span><br><span class="line"><span class="comment">// k = two, v = 2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言简介及安装</title>
    <url>/archives/go-intro-and-install/</url>
    <content><![CDATA[<p>本文主要介绍 Go 语言，以及 Go 语言的安装及环境搭建。</p>
<span id="more"></span>
<h2 id="什么是-go-语言">什么是 Go 语言</h2>
<p>Go 语言是由 Google 开发的一门跨平台的编程语言，最早在2009年发布。</p>
<p>Go 语言具有如下特点：</p>
<ul>
<li>高性能、高并发。在编程语言的层面上实现了高并发，十分容易就可以写出高并发的程序。</li>
<li>语法简单，学习曲线平缓。Go 语言的语法类似
C，同时语法风格较为简洁。</li>
<li>丰富的标准库。Go 语言提供了大量高质量的标准库。</li>
<li>完善的工具链。在编译、格式化、质量检查、包管理、测试等方面拥有完善的工具链。</li>
<li>静态链接。在代码编译之后以单个可执行文件作为构件，可将该可执行文件直接部署。</li>
<li>快速编译。编译速度较快，同时支持增量编译。</li>
<li>跨平台。可以在几乎所有的平台、架构下运行。同时自带交叉编译。</li>
<li>垃圾回收。无需考虑内存管理。</li>
</ul>
<h2 id="go-语言环境配置">Go 语言环境配置</h2>
<h3 id="go-语言安装及配置">Go 语言安装及配置</h3>
<p>进入 <a href="https://go.dev/">Go
语言官网</a>，下载安装最新版即可。</p>
<p>安装完成后，在国内因为某些原因，常常需要配置 proxy 使用。可使用七牛的
<a href="https://goproxy.cn/">goproxy</a> 服务对于 Go 进行加速。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on  # 开启 Go 1.11 module功能</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct # 使用 goproxy 进行加速</span><br></pre></td></tr></table></figure>
<h3 id="使用-vscode-进行-go-开发">使用 VSCode 进行 Go 开发</h3>
<p>安装 <a href="https://code.visualstudio.com">Visual Studio
Code</a>，并安装 <a
href="https://marketplace.visualstudio.com/items?itemName=golang.Go">Go
语言插件</a>，即可进行 Go 语言开发。</p>
<h2 id="第一行-go-代码">第一行 Go 代码</h2>
<p>使用 <code>go mod init github.com/gtn1024/helloworld</code>
命令，即可创建一个新的项目，随后创建
<code>main.go</code>，输入如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目目录中执行 <code>go run .</code> 即可运行该程序。</p>
<img src="/archives/go-intro-and-install/20230115165947.png" class="">
<p>在如上代码中，将包名设置为
<code>main</code>，代表该文件是一个程序的入口文件。Go 语言的程序由
<code>main</code> 包中的 <code>main()</code>
函数启动。<code>import "fmt"</code> 则代表需要导入 <code>fmt</code>
包，该包主要用于程序的字符串和输入输出。<code>fmt.Println("Hello, world!")</code>
则代表输出 <code>Hello, world!</code> 语句。</p>
<h2 id="编译-go-程序">编译 Go 程序</h2>
<h3 id="编译为当前平台可执行程序">编译为当前平台可执行程序</h3>
<p>运行 <code>go build .</code>
即可将当前项目编译成当前平台的可执行文件，该文件可以独立执行而无需任何的依赖。</p>
<img src="/archives/go-intro-and-install/20230115170829.png" class="">
<h3 id="交叉编译其他平台程序">交叉编译其他平台程序</h3>
<p>Go 编译程序可以通过环境变量的方式来切换目标平台。本文使用的是
<code>Git Bash</code>，所以可以直接在命令前面添加环境变量。</p>
<img src="/archives/go-intro-and-install/20230115172126.png" class="">
<p>Go 语言可交叉编译的平台可以由 <code>go tool dist list</code>
命令查看：</p>
<img src="/archives/go-intro-and-install/20230115171820.png" class="">
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GitHub 纯免费方案搭建 Hexo 博客</title>
    <url>/archives/hexo-1/</url>
    <content><![CDATA[<p>现在我们有什么文章往往都会发布到互联网上，一些同学是发布到掘金、CSDN、知乎等平台，还有一些是自己搭建个人的博客平台。本文主要介绍后者，通过
Hexo 搭建个人博客。</p>
<p>Hexo 是基于 Node.js 的纯静态博客系统，即构建以后为纯 HTML
文件。故我们博客可以使用一些托管平台来部署，如 GitHub
Pages、Vercel、Netlify、Cloudflare Pages 等平台。</p>
<p>本文主要是用如下方案进行部署：本地搭建 Hexo 博客，推送到 GitHub
上，使用 GitHub Actions 自动构建并部署至 GitHub Pages。</p>
<span id="more"></span>
<h2 id="安装-node.js">安装 Node.js</h2>
<p>在搭建 Hexo 博客之前，需要先安装 <a
href="https://nodejs.org/zh-cn/">Node.js</a>，打开官网后下载长期维护版即可，目前最新的长期维护版为
<code>16.17.0</code>。</p>
<img src="/archives/hexo-1/16613481023243.jpg" class="">
<p>安装完 Node.js 后，执行 <code>node -v</code> 和
<code>npm -v</code>，如果能够正常显示版本号则安装完成。</p>
<p>如果安装 Node.js 一切正常，能够正常使用 <code>node</code> 和
<code>npm</code> 命令，我们则可以进行下一步——搭建 Hexo 博客。</p>
<h2 id="创建-hexo">创建 Hexo</h2>
<p>运行 <code>npm install hexo-cli -g</code> 命令，在系统全局安装
<code>hexo-cli</code> 工具。该工具可以方便地帮助我们创建 Hexo 项目、创建
Hexo 页面、创建 Hexo 文章。当然，如果你熟悉
<code>yarn</code>、<code>pnpm</code> 等 Node.js
包工具，也可以使用这些工具来安装 <code>hexo-cli</code>。</p>
<p>执行 <code>hexo -v</code>，正常显示各组件版本信息，则安装成功。</p>
<img src="/archives/hexo-1/16613484869822.jpg" class="">
<p>运行 <code>hexo init my-blog</code> 命令，<code>hexo-cli</code>
工具就会在 <code>my-blog</code> 目录下创建一个 Hexo
博客。如果他没有安装依赖，请运行 <code>npm install</code>
安装依赖（注意进入 <code>my-blog</code> 目录）。我个人使用
<code>pnpm</code> 进行包管理。</p>
<img src="/archives/hexo-1/16613488370437.jpg" class="">
<img src="/archives/hexo-1/16613488540908.jpg" class="">
<p>依赖安装成功后可以使用 <code>hexo s</code>
在本地启动服务器便于预览，一般情况下会在本机的 4000 端口开启一个 HTTP
服务。</p>
<img src="/archives/hexo-1/16613490348269.jpg" class="">
<img src="/archives/hexo-1/16613490791853.jpg" class="">
<h2 id="玩转-hexo">玩转 Hexo</h2>
<p>正如在上方预览里文章所说，运行 <code>hexo new</code>
命令可以新建一篇博客，后面需要接上博客的文件名，通常情况下我们使用英文。运行后他会在
<code>source/_posts</code> 目录下创建一个 Markdown
文件，该文件即为新的文章。</p>
<img src="/archives/hexo-1/16613491830259.jpg" class="">
<p>我们对文章进行修改，重新启动服务器进行查看。</p>
<img src="/archives/hexo-1/16613492885900.jpg" class="">
<img src="/archives/hexo-1/16613493607001.jpg" class="">
<p>到这里我们就完成了最基本的博客搭建、文章编写。当然，我们还可以对其进行个性化，比如更换主题什么的。在官网的
<code>Themes</code> 栏目下也有许许多多优质的主题推荐。</p>
<img src="/archives/hexo-1/16613494499545.jpg" class="">
<h2 id="在-github-上创建-git-仓库并推送">在 GitHub 上创建 git
仓库并推送</h2>
<p>我们可以在 GitHub 创建 <code>用户名.github.io</code>
的仓库，该仓库是一个特殊的仓库，开启 GitHub Pages
后可以直接通过该域名来访问 Pages，而其他仓库名则为
<code>用户名.github.io/仓库名</code> 访问。例如，我的 GitHub 用户名是
<code>gtn1024</code>，那么我创建的仓库则为
<code>gtn1024.github.io</code>。</p>
<h2 id="编写-github-actions-脚本实现自动构建">编写 GitHub Actions
脚本实现自动构建</h2>
<p>在仓库根目录创建 <code>.github/workflows/deploy.yml</code>
文件，写入如下 GitHub Actions 脚本，即可自动使用 GitHub Actions
对其进行构建并且部署至 GitHub Pages 上。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">部署</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy-gh-pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">pnpm</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">pnpm/action-setup@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">version:</span> <span class="number">7</span></span><br><span class="line">          <span class="attr">run_install:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">设置</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">          <span class="attr">cache:</span> <span class="string">pnpm</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装依赖</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">install</span> <span class="string">--frozen-lockfile</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">构建</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">NODE_OPTIONS:</span> <span class="string">--max_old_space_size=4096</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">部署文档</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 这是文档部署到的分支名称</span></span><br><span class="line">          <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br><span class="line">          <span class="attr">folder:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>
<p>push 到 GitHub 后，GitHub Actions
将会自动启动构建，如图为构建成功的截图</p>
<img src="/archives/hexo-1/16613503836038.jpg" class="">
<p>最后，我们将 GitHub Pages 分支设置为 <code>gh-pages</code> 即可。</p>
<img src="/archives/hexo-1/16613504369414.jpg" class="">
<h2 id="访问">访问</h2>
<p>访问 <code>用户名.github.io</code> 即可看到刚才搭建的 Hexo 博客。</p>
<img src="/archives/hexo-1/16613505129028.jpg" class="">
<h2 id="还有一些事">还有一些事</h2>
<p>至此，我们 Hexo
博客的雏形已经搭建完成。事实上，我们还有很多事情要做：</p>
<ul>
<li>配置博客描述</li>
<li>换个好看的主题</li>
<li>...</li>
</ul>
<p>将在后续的文章讲解。</p>
]]></content>
      <categories>
        <category>知识科普</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机高级语言的执行方式</title>
    <url>/archives/how-advanced-lang-exec/</url>
    <content><![CDATA[<p><strong>计算机高级语言</strong>按照执行方式来分可以分为<strong>编译型</strong>和<strong>解释型</strong>这两种类型。</p>
<span id="more"></span>
<h2 id="编译型语言">编译型语言</h2>
<p><strong>编译型语言</strong>是指使用针对特定平台的<strong>编译器</strong>将<strong>源代码</strong>「翻译」成针对该平台硬件可以执行的<strong>机器码</strong>，并且打包形成成该平台支持执行的可执行文件。</p>
<img src="/archives/how-advanced-lang-exec/%E7%BC%96%E8%AF%91.png" class="">
<p>常见的编译型语言有：<strong>C</strong>、<strong>C++</strong>、<strong>Go</strong>等等。</p>
<h2 id="解释型语言">解释型语言</h2>
<p><strong>解释型语言</strong>是指使用针对特定平台的<strong>解释器</strong>对<strong>源代码</strong>进行逐行「解释」成特定平台的<strong>机器码</strong>。<strong>解释型语言</strong>不需要进行<strong>编译</strong>，可以理解为解释型语言<strong>边编译边执行</strong>。</p>
<p>举个生活中的例子，假如你在阅读一本英文的书，你可能有如下反应：</p>
<img src="/archives/how-advanced-lang-exec/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80.gif" class="">
<p>常见的解释型语言有：<strong>JavaScript</strong>、<strong>Python</strong>、<strong>Ruby</strong>
等。</p>
<h2 id="编译型与解释型语言的对比">编译型与解释型语言的对比</h2>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 31%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>编译型</th>
<th>解释型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>优点</td>
<td>运行速度快</td>
<td>不需要编译，代码可以在任何带有解释器的机器上运行</td>
</tr>
<tr class="even">
<td>缺点</td>
<td>需要针对不同平台单独编译</td>
<td>运行速度慢</td>
</tr>
</tbody>
</table>
<p>总结：</p>
<p><strong>编译型语言</strong>将程序编译后就相当于两个母语相同的人在交流。</p>
<p><strong>解释型语言</strong>相当于你在看一本外文书，边看边查字典弄懂每句话什么意思。</p>
]]></content>
      <categories>
        <category>知识科普</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 注解笔记</title>
    <url>/archives/java-annotation/</url>
    <content><![CDATA[<p>Java 注解笔记</p>
<span id="more"></span>
<h2 id="理解注解">理解注解</h2>
<p>用法：<code>@注解</code></p>
<p>注解本身是添加在 Java
源程序上的，但注解本身并不会对程序产生影响，只是提供额外的信息。他需要额外的
<strong>注解处理工具</strong>（APT）
来读取注解信息，并根据注解做进一步的处理。</p>
<p>在极端情况下，对于同一个注解，在不同的注解处理工具中，可能产生不同的作用</p>
<h2 id="java-内置常用注解">Java 内置常用注解</h2>
<p>由于是 Java 本身提供的，因此 Java
编译器（javac）默认会提取并且处理这些注解。</p>
<h3 id="override"><code>@Override</code></h3>
<p>该注解要求被修饰的方法必须重写父类、实现方法，否则报错。</p>
<h3 id="deprecated"><code>@Deprecated</code></h3>
<p>该注解用于标注某个类、某个方法、某个成员变量等过时。</p>
<p>该注解有两个重要的参数：</p>
<ul>
<li><code>forRemoval</code>：指定该单元会在将来的版本中被移除；</li>
<li><code>since</code>：指定该单元从哪个版本开始被标记过时。</li>
</ul>
<p>如果调用被标记过时的单元，在编译时会有警告。</p>
<h3 id="suppresswarnings"><code>@SuppressWarnings</code></h3>
<p>用于压制程序的警告。如果 Java
代码中有警告，而确定程序不存在问题，可以使用该注解压制警告。</p>
<p>滥用该注解可能导致负面影响。</p>
<h3 id="堆污染警告和-safevarargs">堆污染警告和
<code>@SafeVarargs</code></h3>
<p>varargs 是个数可变的参数，个数可变的参数本质上是数组。</p>
<p>Java 允许声明泛型数组，但不可以创建泛型数组。除非使用通配符。</p>
<p>如果方法中个数可变的参数带了泛型，可能引发
<strong>堆污染</strong>警告。</p>
<h3 id="functionalinterface"><code>@FunctionalInterface</code></h3>
<p>要求被修饰的接口必须是函数式接口（只能有一个抽象方法），否则报错。</p>
<h2 id="自定义注解">自定义注解</h2>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">	变量类型 变量名() [<span class="keyword">default</span> 默认值];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="标记注解无任何成员变量的注解">标记注解（无任何成员变量的注解）</h3>
<p>该注解没有定义任意成员变量，意味该注解不能指定额外的信息。</p>
<p>这种注解的唯一作用是根据是否出现来传递信息。</p>
<h3 id="元数据注解带成员变量的注解">元数据注解（带成员变量的注解）</h3>
<p>这种注解允许在使用时为成员变量指定值，这样一个注解可以传入多个数据。</p>
<p>当注解只要指定一个 <code>value</code> 成员变量值时，可以省略
<code>value</code> 名称。</p>
<h2 id="jdk-的元注解">JDK 的元注解</h2>
<p>元注解：用于修饰注解。当希望定义自己的注解时，程序使用元注解来修饰。</p>
<h3 id="retention"><code>@Retention</code></h3>
<p>用于指定该注解可以保留到生命时候，<code>value</code> 属性为如下 3
个枚举值：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：被修饰的注解只能保留在源代码中，编译后，该注解就被丢弃。该注解必须在编译时处理。</li>
<li><code>RetentionPolicy.CLASS</code>：被修饰的注解只保留在 class
代码中，被编译后，注解还存在，但程序运行时无法读取。该注解要么在编译时处理，要么去
class 文件读取。</li>
<li><code>RetentionPolicy.RUNTIME</code>：被修饰的注解将一直保留。该注解可以在任意时间处理。</li>
</ul>
<h3 id="target"><code>@Target</code></h3>
<p>用于指定被修饰的注解只能用于修饰什么程序单元。</p>
<p>默认情况下，自定义注解可以修饰任何的程序单元。</p>
<h3 id="documented"><code>@Documented</code></h3>
<p>用于指定被修饰的注解将会被 javadoc 工具提取到文档中。</p>
<h3 id="inherited"><code>@Inherited</code></h3>
<p>用于指定被修饰的注解自动具有继承性。</p>
<p>如，使用 <code>@Inherited</code> 修饰了
<code>@A</code>，<code>@A</code> 修饰了类 B，那么类 B 的子类自动具有
<code>@A</code> 注解。</p>
<h3 id="repeatable"><code>@Repeatable</code></h3>
<p>格式：<code>@Repeatable(容器注解.class)</code></p>
<p>在 Java 8
之前，如果需要重复一个注解修饰相同的程序单元，需要显式使用一个容器注解来包装这些重复的注解。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Foo &#123;</span><br><span class="line">  String name();</span><br><span class="line">&#125;</span><br><span class="line">@interface Foos &#123;</span><br><span class="line">  Foo[] value();</span><br><span class="line">&#125;</span><br><span class="line">@Foos(&#123;</span><br><span class="line">  @Foo(name=&quot;foo&quot;),</span><br><span class="line">  @Foo(name=&quot;bar&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">class Main &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>@Repeatable</code> 后，即可变为如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Repeatable(Foos.class)</span><br><span class="line">@interface Foo &#123;</span><br><span class="line">  String name();</span><br><span class="line">&#125;</span><br><span class="line">@interface Foos &#123;</span><br><span class="line">  Foo[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Foo(name=&quot;foo&quot;)</span><br><span class="line">@Foo(name=&quot;bar&quot;)</span><br><span class="line">class Main &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理注解">处理注解</h2>
<p>处理注解大致可以分为</p>
<ol type="1">
<li>编译时提取注解信息，根据信息作进一步的处理。为 javac 命令指定
<code>-processor</code> 选项指定自己的注解处理工具（APT）类。</li>
<li>运行时程序通过反射提取注解信息（必须是 <code>RUNTIME</code>
保留期）。</li>
</ol>
<h3 id="运行时读取注解">运行时读取注解</h3>
<p>Java 中所有可以被注解修饰的程序单元都实现了
<code>AnnotatedElement</code>
接口，该接口代表所有可接受注解的程序单元。</p>
<p><code>AnnotatedElement</code> 接口提供如下常用方法：</p>
<ul>
<li><code>isAnnotationPresent(注解类)</code>：判断某个注解是否存在</li>
<li><code>getAnnotation(注解类)</code>：获取某个注解</li>
<li><code>getAnnotations()</code>：获取该程序单元上所有的注解</li>
<li><code>getAnnotationsByType(注解类)</code>：获取该程序单元上指定类型的所有注解。主要针对
Java 8 的重复注解。</li>
</ul>
<h3 id="注解处理实例">注解处理实例</h3>
<p>TODO</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 函数式编程详解</title>
    <url>/archives/java-functional-program/</url>
    <content><![CDATA[<p>Java 8 中有着许许多多特别好用的特性，Lambda 表达式就是其中一个。</p>
<span id="more"></span>
<h2 id="函数式接口">函数式接口</h2>
<p><strong>函数式接口</strong>指<strong>只有</strong>一个<strong>抽象方法</strong>的接口。如果定义函数式接口只需在接口上方加入<code>@FunctionalInterface</code>注解。<strong>函数式接口</strong>中可以有<strong>类方法</strong>、<strong>默认方法</strong>等，<strong>但只能有一个抽象方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// 可以有类方法</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 可以有默认方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<strong>Lambda 表达式</strong>出现之前，通常使用 <a
href="/archives/java-oop#匿名内部类"><strong>匿名内部类</strong></a>
来创建实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;匿名内部类测试...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">f.foo();    <span class="comment">// 匿名内部类测试...</span></span><br><span class="line"></span><br><span class="line">System.out.println(Foo.sum(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line">f.bar();    <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<h2 id="lambda-表达式">Lambda 表达式</h2>
<p>由以上代码可见，使用<strong>匿名内部类</strong>时会有大量多余的代码（如<code>new Foo()</code>、重写唯一的抽象方法）。Java
8 引入了 Lambda 表达式，用于简化代码。</p>
<p><strong>Lambda 表达式本质上就是函数式接口的匿名内部类。</strong></p>
<p>以上代码使用 Lambda 表达式则为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;匿名内部类测试...&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>如果该抽象方法有参数，参数不可省略</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> (String name) -&gt; &#123;   <span class="comment">// 参数类型可以省略</span></span><br><span class="line">      System.out.println(<span class="string">&quot;欢迎回来，&quot;</span> + name);</span><br><span class="line">      System.out.println(<span class="string">&quot;——来自Lambda表达式&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    f.foo(<span class="string">&quot;巴掌&quot;</span>);</span><br><span class="line">    <span class="comment">// 欢迎回来，巴掌</span></span><br><span class="line">    <span class="comment">// ——来自Lambda表达式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lambda-表达式简化">Lambda 表达式简化</h2>
<p>Lambda 表达式可以有如下简化：</p>
<ul>
<li>形参列表中参数类型可以省略；</li>
<li>如果形参列表只有一个参数，那么圆括号可以省略；</li>
<li>如果方法体只有一行代码，花括号可以省略；</li>
<li>如果方法体只有一行代码，且为<code>return</code>语句，<code>return</code>可以省略。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> a -&gt; a * a;</span><br><span class="line">    System.out.println(f.foo(<span class="number">5</span>));   <span class="comment">// 25</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法引用和构造器引用-重点">方法引用和构造器引用 (重点)</h2>
<p><strong>当方法体只有一条代码时才可以使用</strong>。<strong>方法引用</strong>本质是<strong>进一步省略形参列表</strong>，形参列表顺序与传入参数的顺序完全相同。</p>
<h3 id="引用类方法">引用类方法</h3>
<p><strong>引用类方法</strong>转化前的格式为<code>(参数列表) -&gt; 类.类方法(参数列表)</code>，转化后为<code>类::类方法</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">min</span><span class="params">(<span class="type">double</span> i1, <span class="type">double</span> i2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//  Foo f = (i1, i2) -&gt; Math.min(i1, i2);</span></span><br><span class="line">    <span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> Math::min;</span><br><span class="line">    System.out.println(f.min(<span class="number">5.0</span>, <span class="number">2.0</span>));  <span class="comment">// 2.0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用实例方法">引用实例方法</h3>
<p><strong>引用实例方法</strong>转化前的格式为<code>(参数1, 其他参数) -&gt; 参数1.实例方法(其他参数)</code>，转化后为<code>类::实例方法</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  String <span class="title function_">sub</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//  Foo f = (s, start, end) -&gt; s.substring(start, end);</span></span><br><span class="line">    <span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> String::substring;</span><br><span class="line">    System.out.println(f.sub(<span class="string">&quot;Java, yes!&quot;</span>, <span class="number">1</span>, <span class="number">4</span>));  <span class="comment">// ava</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用特定对象的实例方法">引用特定对象的实例方法</h3>
<p><strong>引用特定对象的实例方法</strong>转化前的格式为<code>(参数) -&gt; 某对象.实例方法(参数)</code>，转化后为<code>某对象::实例方法</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  String <span class="title function_">sub</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//  Foo f = (start, end) -&gt; &quot;Java, yes!&quot;.substring(start, end);</span></span><br><span class="line">    <span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> <span class="string">&quot;Java, yes!&quot;</span>::substring;</span><br><span class="line">    System.out.println(f.sub(<span class="number">1</span>, <span class="number">4</span>));  <span class="comment">// ava</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器引用">构造器引用</h3>
<p><strong>构造器引用</strong>转化前的格式为<code>(参数) -&gt; 类.构造器(参数)</code>，转化后为<code>类::new</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  StringBuilder <span class="title function_">foo</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//  Foo f = s -&gt; new StringBuilder(s);</span></span><br><span class="line">    <span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> StringBuilder::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(f.foo(<span class="string">&quot;Welcome to Java World!&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="https://union-click.jd.com/jdc?e=&amp;p=JF8BAMUJK1olXDYCV1pdAUoUB19MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksUB28BGlgRQl9HCANtdUpkA2twQgV1PE59KjxDcCNISg1pXVcZbQcyVF9cC04VBWsBHGslXQEyAjBdCUoWAm4NG14WbQcyVFlfC0oTAmYNGVoTWTYFVFdtUx55dQRLWCBQCXlcMgM9OHsnAF84K1slXjZAOlhYARtHBTtaHgsRXwNXA1cNC0hHBTwJGFkSDVJRB1ddOEkWAmsBKw">《疯狂
Java 讲义 · 第 5 版》</a></li>
<li><a href="https://bfw.h5.xeknow.com/s/1YClVz">跟着李刚老师学
Java（视频）</a></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>函数式编程</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO 笔记</title>
    <url>/archives/java-io/</url>
    <content><![CDATA[<p>文件
IO：用于处理数据。将数据保存到文件等其他物理设备上，保证数据可以在断电后持久保存。</p>
<span id="more"></span>
<h2 id="file-类">File 类</h2>
<p><code>File</code>
代表了文件或者目录，用于操作文件或目录本身，不能读取文件内容。</p>
<h2 id="io流">IO流</h2>
<h3 id="流的分类">流的分类</h3>
<p>按照 <strong>方向</strong> 分：</p>
<ul>
<li>输入流：读取数据；</li>
<li>输出流：写出数据。</li>
</ul>
<p>按照 <strong>数据单元</strong> 分：</p>
<ul>
<li>字节流：每次读写一个字节，可以读写任意文件（以 <code>Stream</code>
结尾）；</li>
<li>字符流：每次读写一个字符，可以方便地读写文本文件（以
<code>Reader/Writer</code> 结尾）。</li>
</ul>
<p>按照 <strong>角色</strong> 分：</p>
<ul>
<li>节点流：直接关联代表数据源的 IO 节点</li>
<li>处理流（包装流、过滤流）：建立在其他流的基础之上，用于对其他流进行包装。</li>
</ul>
<p>输入流的基本方法：</p>
<ul>
<li><code>read()</code>：读取一个单位；</li>
<li><code>int read(Object[] buff)</code>：读取N个单位到数组中，返回实际读取的单位数。</li>
</ul>
<p>输出流的基本方法：</p>
<ul>
<li><code>write(int)</code>：输出一个单位；</li>
<li><code>void write(Obejct[] buff)</code>：输出数组中所有数据。</li>
</ul>
<p><strong>节点流</strong> 主要如下：</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 26%" />
<col style="width: 31%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><code>InputStream</code></th>
<th><code>OutputStream</code></th>
<th><code>Reader</code></th>
<th><code>Writer</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>文件</td>
<td><code>FileInputStream</code></td>
<td><code>FileOutputStream</code></td>
<td><code>FileReader</code></td>
<td><code>FileWriter</code></td>
</tr>
<tr class="even">
<td>数组</td>
<td><code>ByteArrayInputStream</code></td>
<td><code>ByteArrayOutputStream</code></td>
<td><code>CharArrayReader</code></td>
<td><code>CharArrayWriter</code></td>
</tr>
<tr class="odd">
<td>字符串</td>
<td></td>
<td></td>
<td><code>StringReader</code></td>
<td><code>StringWriter</code></td>
</tr>
</tbody>
</table>
<p><strong>处理流</strong> 主要如下：</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 26%" />
<col style="width: 31%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><code>FilterInputStream</code></th>
<th><code>FilterOutputStream</code></th>
<th><code>FilterReader</code></th>
<th><code>FilterWriter</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>缓冲流</td>
<td><code>BufferedInputStream</code></td>
<td><code>BufferedOutputStream</code></td>
<td><code>BufferedReader</code></td>
<td><code>BufferedWriter</code></td>
</tr>
<tr class="even">
<td>打印流</td>
<td></td>
<td><code>PrintStream</code></td>
<td></td>
<td><code>PrintWriter</code></td>
</tr>
<tr class="odd">
<td>转换流</td>
<td></td>
<td></td>
<td><code>InputStreamReader</code></td>
<td><code>OutputStreamWriter</code></td>
</tr>
<tr class="even">
<td>特殊流</td>
<td><code>DataInputStream</code></td>
<td><code>DataOutputStream</code></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>对象流</td>
<td><code>ObjectInputStream</code></td>
<td><code>ObjectOutputStream</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="缓冲流">缓冲流</h3>
<p>内存速度 &gt; 外设速度</p>
<p>如果让内存输出一个数据单元，然后外设处理一个数据单元，必须等外设处理好数据单元之后，内存才会在此输出下一个单元。此时必然会造成性能浪费。</p>
<p>使用缓冲流，内存首先将所有数据输出到缓冲区，缓冲区中的数据留给外设慢慢处理。</p>
<p>使用缓冲流时，需要使用 <code>flush()</code>
方法将数据冲到外设中。</p>
<p>如果使用 <code>close()</code> 关闭流，程序保证会先执行
<code>flush()</code>。</p>
<h3 id="打印流">打印流</h3>
<p><code>System.out</code>、<code>System.err</code> 均为
<code>PrintStream</code> 对象。</p>
<p><strong>总结</strong>：</p>
<p>一般而言，输入使用 <code>BufferedReader</code>，输出使用
<code>PrintStream</code>。</p>
<h3 id="转换流">转换流</h3>
<p>将字节流转换成字节流。很多情况下，程序拿到的是字节流，但确认数据只可能为字符，此时将字节流转换为字符流。</p>
<h3 id="特殊流">特殊流</h3>
<p><code>DataInputStream</code> 提供一系列 <code>readXxx()</code>
方法用于读取不同类型的数据。</p>
<p><code>DataOutputStream</code> 提供一系列 <code>writeXxx()</code>
方法用于写出不同类型的数据。</p>
<p><code>DataInputStream</code> 和 <code>DataOutputStream</code> 是使用
Java 内部格式来记录数据的，因此 <code>DataOutputStream</code>
输出的数据应该使用 <code>DataInputStream</code> 来读取。</p>
<h3 id="重定向标准输入输出">重定向标准输入输出</h3>
<p>标准输出默认为屏幕。<code>System.setOut(PrintStream out)</code>
方法可以将输出重定向到另一个流。</p>
<p>标准输入默认为键盘。<code>System.setIn(InputStream in)</code>
方法可以将输入重定向到另一个流。</p>
<h3 id="读取其他进程的数据">读取其他进程的数据</h3>
<p><code>Runtime</code> 类中的 <code>exec()</code>
方法可用于运行平台上的程序，该方法返回运行的 <code>Process</code>
对象。</p>
<p><code>Process</code> 提供如下当法：</p>
<ul>
<li><code>InputStream getErrorStream()</code>：返回进程错误的输入流。</li>
<li><code>InputStream getInputStream()</code>：返回进程标准输入流。</li>
<li><code>OutputStream getOutputStream()</code>：返回进程的标准输出流。</li>
</ul>
<h3 id="randomaccessfile"><code>RandomAccessFile</code></h3>
<p><code>RandomAccessFile</code> 指任意访问，只能读写文件。</p>
<p>输出流不能追加内容，但 <code>RandomAccess</code> 可以。</p>
<p><code>RandomAccessFile</code>
通常可用于实现多线程、断点下载工具。</p>
<h3 id="对象序列化">对象序列化</h3>
<p>序列化：将内存中的 Java
对象转换成字节文件（二进制文件），该二进制文件内容既可以保存到磁盘，也可以通过网络传输。
反序列化：将二进制数据恢复为原始的 Java 对象。</p>
<p>广义上来说，Java 序列化还包括 XML 序列化、JSON 序列化。</p>
<p><code>Serializable</code>：标志接口，实现该接口的对象即可被序列化。</p>
<h4 id="transient-关键字"><code>transient</code> 关键字</h4>
<p>有些时候，程序希望将某些 field 排除在序列化机制之外，可使用
<code>transient</code> 关键字修饰。</p>
<p>Java 不会序列化：</p>
<ul>
<li>方法</li>
<li><code>transient</code> 修饰的实例变量</li>
<li><code>static</code> 变量</li>
</ul>
<h4 id="自定义序列化">自定义序列化</h4>
<p>类可以通过实现如下方法实现自定义序列化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span></span><br><span class="line"> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br></pre></td></tr></table></figure>
<h4 id="序列化版本">序列化版本</h4>
<p>当程序要反序列化时，需要两个东西才能反序列化成功：</p>
<ul>
<li>序列化的数据</li>
<li>类文件</li>
</ul>
<p>Java 序列化机制识别一个类是否发生了改变，依赖的是 Java
类的序列化版本。</p>
<p>一个可序列化的 Java 类，总有一个序列化版本号：</p>
<ol type="1">
<li>如果没有显式指定，系统会为他分配一个序列化版本号。只要 Java
源程序发生修改，编译后会重新生成一个新的版本号。</li>
<li>显式指定一个序列化版本号。</li>
</ol>
<p>序列化版本号可以使用 <code>serialver</code> 命令查看。</p>
<p>推荐开发者为自己的类指定序列化版本号，只有当增加、删除实例变量时才需要增加版本号。</p>
<h2 id="nio">NIO</h2>
<p>NIO 的出现，进一步简化了 IO 操作</p>
<h3 id="path"><code>Path</code></h3>
<p><code>Path</code>
代表一条路径（既可是文件的路径，也可是目录的路径）</p>
<p>可以通过 <code>Path.of()</code> 方法获取 <code>Path</code> 对象。</p>
<h3 id="files-工具类"><code>Files</code> 工具类</h3>
<p><code>Files</code> 类为文件 IO
的工具类。文件复制、移动、删除、重命名等操作都可以实现。</p>
<p>可以使用 <code>Files.walk()</code> /
<code>Files.walkFileTree()</code> 方法遍历目录。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17新特性：密封类</title>
    <url>/archives/java-sealed-class/</url>
    <content><![CDATA[<p>在 Java 17 之前，一个 Java 类只有两种状态：可派生和不可派生（即
<code>final</code>
类），这导致如果需要对类进行派生的时候，我们无法将其设置为
<code>final</code> 类，也就无法限制其他人对于该类的派生。</p>
<p>Java 17
带来的密封类解决了这个问题，可以限制父类只能派生预先指定的子类，不允许再派生其他子类。</p>
<span id="more"></span>
<h2 id="密封类语法">密封类语法</h2>
<p>密封类的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] <span class="keyword">sealed</span> class 类名 <span class="keyword">permits</span> 子类列表 &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用密封类时没必须满足以下要求：</p>
<ul>
<li>子类和密封类要么处于同一个模块，要么术语同一个类。如果在未命名的模块中，则必须位于同一个包中。</li>
<li>密封类允许派生的子类必须直接继承密封类。</li>
<li>密封类的子类必须使用 <code>final</code>、<code>sealed</code> 或
<code>non-sealed</code> 修饰。
<ul>
<li><code>final</code>：无法再次派生子类。</li>
<li><code>sealed</code>：子类仍然为密封类。</li>
<li><code>non-sealed</code>：非密封类，可以自由派生子类。</li>
</ul></li>
</ul>
<h2 id="密封类例子">密封类例子</h2>
<p>密封类 A 允许派生 B 和 C</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">permits</span> B, C &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>B 同样为密封类，允许派生出 D</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">permits</span> D &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>D 为 <code>final</code> 类，即无法再进行派生子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>C 为非密封类，允许进行任意派生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">non-sealed</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>对应的继承关系图如下：</p>
<img src="/archives/java-sealed-class/image-20221225180518140.png" class="">
<p>特别地，如果密封类和子类均位于同一个文件中，<code>permits</code>
可以省略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">non-sealed</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="密封接口">密封接口</h2>
<p>密封接口与密封类类似，密封接口的实现类也必须使用
<code>sealed</code>、<code>non-sealed</code>、<code>final</code>
修饰，而密封接口下的子接口也必须为
<code>sealed</code>、<code>non-sealed</code> 修饰（接口不可能为
<code>final</code> 修饰）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123; &#125;</span><br><span class="line"><span class="keyword">non-sealed</span> <span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123; &#125;</span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Tar</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123; &#125;</span><br><span class="line"><span class="keyword">non-sealed</span> <span class="keyword">class</span> <span class="title class_">Mar</span> <span class="keyword">extends</span> <span class="title class_">Tar</span> &#123; &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Par</span> <span class="keyword">implements</span> <span class="title class_">Bar</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面向对象知识详解</title>
    <url>/archives/java-oop/</url>
    <content><![CDATA[<p>Java
作为一门纯面向对象的编程语言，对于面向对象有着深刻的了解是必备的。</p>
<span id="more"></span>
<h2 id="tldr">TL;DR</h2>
<p>面向对象 3
大类型：<strong>类</strong>、<strong>接口</strong>、<strong>枚举</strong>。</p>
<p>面向对象 4 大修饰符：<code>private</code> | <code>protected</code> |
<code>public</code>(互斥)、<code>static</code>、<code>final</code>、<code>abstract</code>。</p>
<p>面向对象 5
大成员：<strong>成员变量</strong>、<strong>方法</strong>、<strong>构造器</strong>、<strong>初始化块</strong>、<strong>内部类</strong>。</p>
<h2 id="总述">总述</h2>
<p><strong>面向对象编程</strong>(Object-Oriented Programming, 简称
<strong>OOP</strong>)是一种编程范式。</p>
<p>在<strong>面向对象编程</strong>中，有两个重要的概念：</p>
<ul>
<li><strong>类</strong>：一类事物的统称（例如<strong>动物</strong>类）</li>
<li><strong>对象</strong>：某个<strong>类</strong>中的实例（例如<strong>狗</strong>、<strong>猫</strong>）</li>
</ul>
<p>在一个类中，有<strong>成员变量</strong>(<strong>field</strong>)、<strong>方法</strong>(<strong>method</strong>)、<strong>构造器</strong>(<strong>constructor</strong>)、<strong>初始化块</strong>、<strong>内部类</strong>(<strong>nested
class</strong>)五大成员。</p>
<p><strong>牢记</strong>：</p>
<p><strong>始终只定义你所关心的项目！</strong></p>
<p><strong>始终只定义你所关心的项目！</strong></p>
<p><strong>始终只定义你所关心的项目！</strong></p>
<p>举个例子：现定义一个<strong>人类</strong>(<strong>Human</strong>)，<strong>成员变量</strong>可以有<strong>姓名</strong>(<strong>name</strong>)、<strong>性别</strong>(<strong>gender</strong>)、<strong>年龄</strong>(<strong>age</strong>)、<strong>身高</strong>(<strong>height</strong>)、<strong>体重</strong>(<strong>weight</strong>)等，<strong>方法</strong>可以有<strong>走</strong>(<strong>walk</strong>)、<strong>跑</strong>(<strong>run</strong>)、<strong>跳</strong>(<strong>jump</strong>)、<strong>吃</strong>(<strong>eat</strong>)等。</p>
<p>对应的 <a
href="https://en.wikipedia.org/wiki/Unified_Modeling_Language">UML
图</a>为：</p>
<img src="/archives/java-oop/16317985375578.jpg" class="">
<h2 id="初识面向对象">初识面向对象</h2>
<h3 id="定义类">定义类</h3>
<p>在 Java 中，定义<strong>类</strong>的统一格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类名 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<strong>修饰符</strong>（<strong>可省略</strong>）中的<strong>访问权限</strong>只能为<code>public</code>（<strong>公开类</strong>），其他<strong>修饰符</strong>只能为<code>final</code>或<code>abstract</code>(<strong>抽象类</strong>)。</p>
<p><strong>类名</strong>则为<strong>合法的标识符</strong>，一般采用<strong>大驼峰命名法</strong>来表示。（详见
<a href="https://en.wikipedia.org/wiki/Camel_case">驼峰命名法</a> ）</p>
<h3 id="成员变量">成员变量</h3>
<p>在 Java 中，定义<strong>成员变量</strong>的统一格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 类型 成员变量名 [= 初始值];</span><br></pre></td></tr></table></figure>
<p>其中，<strong>修饰符</strong>（<strong>可省略</strong>）中的<strong>访问权限</strong>可以为<code>public</code>|<code>protected</code>|<code>private</code>。其他<strong>修饰符</strong>可以为<code>final</code>、<code>static</code>。</p>
<p><strong>类型</strong>可以为任意的<strong>基本类型</strong>或<strong>引用类型</strong>。</p>
<p><strong>成员变量名</strong>同样为<strong>合法的标识符</strong>，一般采用<strong>小驼峰命名法</strong>来表示。<strong>成员变量名</strong>通常为<strong>名词</strong>（如<strong>身高</strong>、<strong>体重</strong>）。</p>
<p><strong>初始值</strong>可以省略，如不显式指定初始值则为该类型的默认值（数值型为<code>0</code>，布尔型为<code>False</code>，引用类型为<code>null</code>）。</p>
<h3 id="方法">方法</h3>
<p>在 Java
中，<strong>方法</strong>必须定义在<strong>类</strong>中，不能单独存在。定义<strong>方法</strong>的统一格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名( [形参列表] ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果声明了返回值类型，必须有 return 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<strong>修饰符</strong>（<strong>可省略</strong>）中的<strong>访问权限</strong>可以为<code>public</code>|<code>protected</code>|<code>private</code>。其他<strong>修饰符</strong>可以为<code>final</code>|<code>abstract</code>、<code>static</code>。</p>
<p><strong>返回值类型</strong>可以为任意的<strong>基本类型</strong>或<strong>引用类型</strong>，也可以为<code>void</code>（无返回值）。</p>
<p><strong>方法名</strong>为<strong>合法的标识符</strong>，一般采用<strong>小驼峰命名法</strong>来表示。<strong>方法名</strong>通常为<strong>动词</strong>（如<strong>走</strong>、<strong>跑</strong>）。</p>
<h3 id="构造器">构造器</h3>
<p><strong>构造器</strong>的作用是在<code>new</code>一个对象时自动执行的方法。如果没有为类创建构造器，Java
会<strong>自动</strong>创建一个<strong>无参构造器</strong>。</p>
<p>在 Java 中，定义<strong>构造器</strong>的统一格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 类名( [形参列表] ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：构造器名只能与类名相同，且不能写返回值类型</strong></p>
<p>其中，<strong>修饰符</strong>（<strong>可省略</strong>）只能为<code>public</code>|<code>protected</code>|<code>private</code>。</p>
<h2 id="关键字">关键字</h2>
<h3 id="访问控制">访问控制</h3>
<p>Java 面向对象中访问权限有 3 个（从小到大排序）：</p>
<ul>
<li><code>private</code>：<strong>类访问权限</strong>，只能在该类中被访问（彻底隐藏）。</li>
<li><strong>默认</strong>(不写)：<strong>包访问权限</strong>，只能在该类和该类所在的包中被访问（部分隐藏）。</li>
<li><code>protected</code>：<strong>子类访问权限</strong>，只能在该类、该类所在的包及该类的子类中被访问（部分暴露）。</li>
<li><code>public</code>：<strong>公共访问权限</strong>，该类可以在任意地方来访问（彻底暴露）。</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><code>private</code></th>
<th style="text-align: center;">默认</th>
<th style="text-align: center;"><code>protected</code></th>
<th style="text-align: center;"><code>public</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">当前类</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="even">
<td style="text-align: center;">当前包</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="odd">
<td style="text-align: center;">子类</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="even">
<td style="text-align: center;">任意</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">✅</td>
</tr>
</tbody>
</table>
<h3 id="static">static</h3>
<p>有<code>static</code>的成员属于<strong>类成员</strong>，无<code>static</code>的成员属于<strong>实例成员</strong>。<code>static</code>只能修饰<strong>成员变量</strong>、<strong>方法</strong>、<strong>初始化块</strong>、<strong>内部类</strong>。</p>
<p>使用<code>static</code>修饰的成员，<strong>通常</strong>使用<code>类名.成员名</code>访问。</p>
<p>注意：</p>
<ul>
<li>Java
允许通过实例对象来访问<code>static</code>成员，但并<strong>不推荐</strong>这么做。</li>
<li><strong>非<code>static</code>成员可以访问<code>static</code>成员，相反，<code>static</code>成员不能调用非<code>static</code>成员。</strong></li>
</ul>
<h3 id="this">this</h3>
<h4 id="this-引用">this 引用</h4>
<p><code>this</code>可以出现在非<code>static</code>的<strong>方法</strong>、<strong>构造器</strong>中。用于代表当前正在使用的对象（谁调用他就代表谁）。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Flower</span> &#123;</span><br><span class="line">  String color;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Flower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&quot;yellow&quot;</span>; <span class="comment">// 创建对象时将颜色设置为 黄色</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;已修改&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&quot;red&quot;</span>;    <span class="comment">// 将当前对象的颜色修改为 红色</span></span><br><span class="line">    <span class="built_in">this</span>.output();         <span class="comment">// 调用当前对象中的 output 方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="this-调用">this 调用</h4>
<p>可以通过<code>this(参数)</code>来调用该类的对应构造器，具体可见下方的<strong>构造器重载</strong>。</p>
<h3 id="super">super</h3>
<h4 id="super-限定">super 限定</h4>
<p>与<strong>this
引用</strong>类似，<code>super</code>用于限定访问父类的<strong>实例变量</strong>、<strong>实例方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Base中的foo方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sub中的foo重写方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(foo);       <span class="comment">// 200 (Sub类)</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>.foo);  <span class="comment">// 200 (Sub类)</span></span><br><span class="line">    System.out.println(<span class="built_in">super</span>.foo); <span class="comment">// 20 (Base类)</span></span><br><span class="line"></span><br><span class="line">    bar();        <span class="comment">// Sub中的foo重写方法 (Sub类)</span></span><br><span class="line">    <span class="built_in">this</span>.bar();   <span class="comment">// Sub中的foo重写方法 (Sub类)</span></span><br><span class="line">    <span class="built_in">super</span>.bar();  <span class="comment">// Base中的foo方法 (Base类)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用父类构造器">调用父类构造器</h4>
<p>与<strong>this 调用</strong>类似，用于调用父类构造器。</p>
<p>子类构造器<strong>一定</strong>要调用父类构造器<strong>一次</strong>。如果<strong>子类构造器</strong>没有显式调用<strong>父类构造器</strong>，系统将在<strong>子类构造器</strong>开头<strong>自动调用</strong>父类<strong>无参构造</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Fruit</span><span class="params">(<span class="type">double</span> weight)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(<span class="type">double</span> weight, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(weight);</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="final">final</h3>
<p><code>final</code>可以修饰<strong>变量</strong>（<strong>成员变量</strong>、<strong>局部变量</strong>）、<strong>方法</strong>、<strong>类</strong>。与<code>abstract</code>互斥。</p>
<h4 id="final修饰变量"><code>final</code>修饰变量</h4>
<p>当<code>final</code>修饰<strong>变量</strong>时，必须为该变量赋初始值，且<strong>无法重新赋值</strong>（对象可以进行修改）。</p>
<ul>
<li>当<code>final</code>修饰<strong>实例变量</strong>时，必须显式指定初始值，且只能在<strong>定义时</strong>、<strong>实例初始化块</strong>、<strong>各构造器</strong>其中的一个位置指定。</li>
<li>当<code>final</code>修饰<strong>类变量</strong>时，必须显式指定初始值，且只能在<strong>定义时</strong>、<strong>类初始化块</strong>其中的一个位置指定。</li>
</ul>
<h4 id="final的宏替换"><code>final</code>的宏替换</h4>
<p>当变量满足以下条件时，该变量出现的所有地方将会被替换成变量的值：</p>
<ul>
<li>变量有<code>final</code>修饰</li>
<li>声明时指定了初始值</li>
<li>变量初始值可在编译时确定</li>
</ul>
<img src="/archives/java-oop/16323961305864.jpg" class="">
<h4 id="final修饰方法"><code>final</code>修饰方法</h4>
<p><code>final</code>修饰方法指不允许被子类<strong>重写</strong>，避免该方法被子类破坏。</p>
<h4 id="final修饰类"><code>final</code>修饰类</h4>
<p><code>final</code>修饰类以后该类<strong>不允许</strong>派生子类。</p>
<h3 id="abstract">abstract</h3>
<p><code>abstract</code>只能修饰<strong>类</strong>和<strong>方法</strong>，且与<code>final</code>互斥。</p>
<h4 id="抽象类">抽象类</h4>
<p><strong>抽象类</strong>指使用<code>abstract</code>修饰的类，主要作用是<strong>派生子类</strong>。</p>
<p><strong>抽象类</strong>有以下特性：</p>
<ul>
<li>抽象类<strong>可以有</strong>抽象方法。</li>
<li>抽象类<strong>无法</strong>创建对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象方法">抽象方法</h4>
<p><strong>抽象方法</strong>指<strong>只有方法签名，无方法体</strong>的方法。<strong>抽象方法必须被子类重写，否则不能被调用。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="comment">// 不能有方法体</span></span><br></pre></td></tr></table></figure>
<h2 id="面向对象三大特征">面向对象三大特征</h2>
<h3 id="封装">封装</h3>
<p>封装包含两方面含义：</p>
<ul>
<li><strong>隐藏</strong>：将内部实现细节隐藏</li>
<li><strong>暴露</strong>：通过暴露的接口来操作对象。</li>
</ul>
<p>封装的要求：<strong>合理隐藏，合理暴露。</strong></p>
<p>封装主要是通过<strong>访问控制修饰符</strong>来实现</p>
<p>在 Java
中，<strong>实例变量</strong>通常使用<code>private</code>来修饰，将其隐藏。并提供相应的<code>getter</code>、<code>setter</code>方法，来控制该成员变量的访问。</p>
<p>如下代码所示，<code>User</code>类中有一个成员变量（<code>name</code>），要求<code>name</code>的长度在
10 位以内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;名称长度必须在10位以内！&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承">继承</h3>
<p>继承最大好处是<strong>代码复用</strong>。</p>
<p>Java
中继承是<strong>类与类</strong>之间的关系（而非对象与对象之间的关系），是一种<strong>由一般到特殊</strong>的关系（如<strong>苹果类</strong>(<strong>子类</strong>、<strong>派生类</strong>)继承了<strong>水果类</strong>(<strong>父类</strong>、<strong>超类</strong>、<strong>基类</strong>)），<strong>子类的实例可以当作父类的实例来使用</strong>。</p>
<p>在 Java 中，<strong>继承</strong>通过如下语法定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 子类名 extends 父类 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>Java 是单继承父类，只能有 <strong>1 个直接继承的父类</strong>。</li>
<li>如果不显式继承父类，Java 默认继承<code>Object</code>类。</li>
</ul>
<p>子类可以调用父类非<code>private</code>修饰的<strong>成员变量</strong>、<strong>方法</strong>（见上方<strong>访问控制</strong>表格）。</p>
<h3 id="多态">多态</h3>
<p><strong>多态</strong>是指同一个类型的多个实例，在执行同一个方法时，呈现出多种行为特征。</p>
<h4 id="变量的类型">变量的类型</h4>
<p><strong>编译时类型</strong>：声明该变量时指定的类型。在 Java
程序编译阶段，Java
编译器只认<strong>编译时类型</strong>。当调用子类有而父类没有的方法，且使用<strong>向上转型</strong>时，编译器将报错。</p>
<p><strong>运行时类型</strong>：该变量实际所引用的类型。</p>
<h4 id="向上转型">向上转型</h4>
<p>子类的对象可以直接赋值给父类变量，其可以自动完成。</p>
<p>例如，<strong>Ostrich 类</strong>继承了<strong>Bird
类</strong>，那么定义<strong>Ostrich</strong>实例时可以进行如下定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;飞咯~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不会飞呀~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Bird</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">    <span class="type">Bird</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ostrich</span>();</span><br><span class="line"></span><br><span class="line">    b1.fly();  <span class="comment">// 飞咯~</span></span><br><span class="line">    b2.fly();  <span class="comment">// 不会飞呀~</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向下转型-强制转换">向下转型 (强制转换)</h4>
<p>当使用<strong>向上转型</strong>特性时，想要调用子类方法时，需要强制转换成对应类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;飞咯~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;跑得快呢&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Bird</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ostrich</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1.run(); // 无法编译</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Ostrich</span> <span class="variable">b2</span> <span class="operator">=</span> (Ostrich) b1;</span><br><span class="line">    b2.run(); <span class="comment">// 正常编译</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>强转运算符只能在编译类型具有继承关系的变量之间进行强转，否则编译将会报错（如<code>String</code>类型强转成<code>Integer</code>）。</li>
<li>如果在编译类型具有继承关系的变量之间转换时，如果被转变量的实际类型不是要转换的目标类型，程序就会引发<code>ClassCastException</code>异常。</li>
</ul>
<h4 id="instanceof">instanceof</h4>
<p>为了避免<code>ClassCastException</code>异常，Java
提供了<code>instanceof</code>运算符。格式是<code>变量名 instanceof 类型</code>，当变量所引用的对象是后面类或子类的实例时，返回<code>true</code>。</p>
<p><strong>instanceof
只能在具有继承关系的变量之间进行强转，否则编译将会报错，故当变量与类之间没有关系时，也不会返回<code>false</code>。</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    <span class="keyword">if</span>(fruit <span class="keyword">instanceof</span> Apple) &#123;</span><br><span class="line">      <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> (Apple)fruit;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 Java 16 开始，instanceof 运算符得到了升级。见本文最后<strong>Java
16 增强的 instanceof</strong>。</p>
<h2 id="面向对象重点">面向对象重点</h2>
<h3 id="方法重载">方法重载</h3>
<p><strong>方法重载</strong>(<code>Overload</code>)指<strong>方法名相同，形参列表不同的方法</strong>。Java
通过参数类型来判断该方法是否为重载方法。<strong>修饰符不同或返回值类型不同的方法不能称为方法重载！</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;哦吼？&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;商品名：&quot;</span>+ name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;商品名：&quot;</span> + name + <span class="string">&quot;, 价格：&quot;</span> + price);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    show();            <span class="comment">// 哦吼？</span></span><br><span class="line">    show(<span class="string">&quot;手机&quot;</span>);       <span class="comment">// 商品名：手机</span></span><br><span class="line">    show(<span class="string">&quot;平板&quot;</span>, <span class="number">3000</span>); <span class="comment">// 商品名：平板, 价格：3000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器重载">构造器重载</h3>
<p><strong>构造器重载</strong>要求<strong>形参列表不同</strong>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个问题，就是当需要为某个成员统一修改时，可能需要一一修改构造器。例如，需要在<code>name</code>成员前添加<code>Dog:</code>的前缀，需要一一修改构造器。</p>
<p>这里可以通过<code>this(参数)</code>来调用对应的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Dog: &quot;</span> + name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(name);  <span class="comment">// 调用 `public Dog(String)` 构造器</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法重写">方法重写</h3>
<p><strong>方法重写</strong>(<code>Override</code>)是指<strong>子类</strong>将<strong>父类</strong>的方法重写。<strong>方法重写</strong>要求<strong>方法名、形参列表相同，返回值类型、声明抛出的异常相同或更小(即子类)，访问权限相同或更大</strong>。</p>
<p><strong>重写的方法</strong>通常使用<code>@Override</code>注解来修饰（<strong>避免重写错代码</strong>）。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;鸟飞咯&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;鸵鸟不会飞……&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tostring-与-equals-方法">toString 与 equals 方法</h3>
<p><code>toString</code>方法是将当前对象以<strong>文本的方式</strong>来表示出来，Java
默认的<code>toString</code>方法是<code>类名@哈希码</code>的格式，通常我们重写该方法将其内部的成员变量表示出来。</p>
<p><code>equals</code>方法则是用于比较两个对象是否相同，Java
默认通过比较两个引用变量是否指向同一个对象，通常我们重写该方法使用<strong>该类的关键属性</strong>来比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="comment">// 有参构造</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Getter / Setter 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// toString 方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person[name=&quot;</span> + name</span><br><span class="line">         + <span class="string">&quot;, age=&quot;</span> + age</span><br><span class="line">         + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// equals 方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 同一个对象</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == Person.class) &#123;</span><br><span class="line">      <span class="comment">// obj不为null且obj和当前对象的类相同</span></span><br><span class="line">      <span class="type">Person</span> <span class="variable">target</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(target.getName())</span><br><span class="line">             <span class="comment">// String类型需要使用equals方法比较</span></span><br><span class="line">          &amp;&amp; <span class="built_in">this</span>.age == target.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王强&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王强&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(p1);     <span class="comment">// Person[name=王强, age=18]</span></span><br><span class="line">    System.out.println(p2);     <span class="comment">// Person[name=王强, age=18]</span></span><br><span class="line">    System.out.println(p3.toString()); <span class="comment">// Person[name=张三, age=30]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1.equals(p2))          <span class="comment">// true</span></span><br><span class="line">      System.out.println(<span class="string">&quot;p1和p2是同一个人&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化块">初始化块</h3>
<p><strong>初始化块</strong>的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<strong>修饰符</strong>只能出现<code>static</code>，无<code>static</code>修饰的称为<strong>实例初始化块</strong>，有<code>static</code>修饰的称为<strong>类初始化块</strong>。</p>
<h4 id="实例初始化块">实例初始化块</h4>
<p><strong>实例初始化块</strong>实际上是「<strong>假象</strong>」，块中所有代码在<strong>编译</strong>时将会被<strong>还原到每个构造器的最前面</strong>。左图为编译前的原始代码，右图为<code>class</code>文件反编译的代码。</p>
<img src="/archives/java-oop/16322017907275.jpg" class="">
<p><strong>实例初始化块</strong>的作用是<strong>将各个构造器前相同的代码抽离到实例初始化块，从而实现代码复用</strong>。</p>
<h4 id="类初始化块">类初始化块</h4>
<p><strong>类初始化块</strong>负责对类进行初始化。当程序<strong>第一次主动使用</strong>(除了<strong>仅使用该类声明变量</strong>)该类时，系统会为该类分配内存空间，并调用类初始化块。程序运行时，该类初始化块只执行一次。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">执行次数</th>
<th style="text-align: center;">执行先后</th>
<th style="text-align: center;">执行时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">类初始化块</td>
<td style="text-align: center;">1 次</td>
<td style="text-align: center;">先</td>
<td style="text-align: center;">第一次<strong>主动</strong>使用该类</td>
</tr>
<tr class="even">
<td style="text-align: center;">实例初始化块</td>
<td style="text-align: center;">N 次</td>
<td style="text-align: center;">后</td>
<td style="text-align: center;">每次调用构造器</td>
</tr>
</tbody>
</table>
<h3 id="抽象类-1">抽象类</h3>
<p>见上面<code>abstract</code>关键字</p>
<h3 id="接口">接口</h3>
<p><strong>接口</strong>相当于一个彻底抽象的类，体现<strong>一种规范</strong>。接口中所有东西都使用<code>public</code>修饰（通常省略）。接口支持多继承。</p>
<h4 id="接口定义">接口定义</h4>
<p>接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] interface 接口名 [extends 父接口<span class="number">1</span>, 父接口<span class="number">2</span>, ...] &#123;</span><br><span class="line">  <span class="comment">// 成员变量（常量，自动使用`public static final`修饰）</span></span><br><span class="line">  <span class="comment">// 抽象方法：Java 8 后支持类方法、默认方法（带有方法体的抽象方法，与实例方法类似）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<strong>修饰符</strong>只能为<code>public</code>。<strong>接口名</strong>命名规范基本与类名系统，通常使用形容词来定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="comment">// 反编译后：</span></span><br><span class="line">  <span class="comment">// public static final int MAX_WEIGHT = 100;</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">MAX_WEIGHT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;  <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java 8 后的类方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java 8 后的默认方法</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用接口">使用接口</h4>
<p>使用接口中<strong>成员变量</strong>、<strong>类方法</strong>时，与调用类成员相似，即<code>接口名.成员名</code>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(MyInterface.MAX_WEIGHT); <span class="comment">// 100</span></span><br><span class="line">    MyInterface.staticMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现接口">实现接口</h4>
<p><strong>子类要么重写接口中所有抽象方法，要么定义为抽象类。</strong></p>
<p>实现接口的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类名 implements 父接口<span class="number">1</span> [, 父接口<span class="number">2</span>, ...] &#123;</span><br><span class="line">  <span class="comment">// 5大成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以实现上方的接口为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>private</code>方法本质是实例方法。</strong></p>
<h3 id="内部类">内部类</h3>
<p><strong>内部类</strong>是在类体中定义的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 外部类 &#123;</span><br><span class="line">  [修饰符] class 内部类 [extends 父类] [implements 接口] &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内部类</strong>与<strong>外部类</strong>的区别如下：</p>
<ul>
<li><strong>内部类</strong>与<strong>外部类</strong>相比可使用<code>static</code>、<code>private</code>、<code>protected</code>修饰符。</li>
<li>非静态内部类<strong>不能</strong>拥有静态成员（<strong>常量除外</strong>）。</li>
<li>内部类可以直接访问外部类私有成员，但静态内部类不能访问外部类的非静态成员。</li>
</ul>
<p><strong>内部类的意义</strong>：当某个类的实例必须依附于另一个类存在时，可使用内部类。且内部类可以提供更好的封装（可使用<code>private</code>修饰）。</p>
<p>内部类生成的文件名格式为：<code>外部类$内部类.class</code></p>
<h4 id="内部类区分同名变量">内部类区分同名变量</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">      System.out.println(length);            <span class="comment">// 2000</span></span><br><span class="line">      System.out.println(<span class="built_in">this</span>.length);       <span class="comment">// 200</span></span><br><span class="line">      System.out.println(Foo.<span class="built_in">this</span>.length);   <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用内部类">使用内部类</h4>
<p><strong>（1）在外部类中使用内部类</strong></p>
<p>基本与使用其他类相同，需要注意的是<strong>静态成员不能使用非静态内部类创建实例</strong>。</p>
<p><strong>（2）在外部类的外面使用静态内部类</strong></p>
<p><strong>该内部类不能使用<code>private</code>修饰</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;我来自Foo.Bar.test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Foo.Bar.test();  <span class="comment">// 我来自Foo.Bar.test()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）在外部类的外面使用非静态内部类 (不常见)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;非静态内部类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    Foo.<span class="type">Bar</span> <span class="variable">fb</span> <span class="operator">=</span> foo.<span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"></span><br><span class="line">    fb.test(); <span class="comment">// 非静态内部类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="局部内部类">局部内部类</h4>
<p>定义在方法中的内部类，不常用，略。</p>
<h4 id="匿名内部类">匿名内部类</h4>
<p><strong>匿名内部类</strong>指没有名字的类，无法复用。</p>
<p>匿名内部类的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器(参数)|接口() &#123;</span><br><span class="line">  <span class="comment">// 除了构造器，其他都可以定义</span></span><br><span class="line">  <span class="comment">// 但一般只实现抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>匿名内部类必须显式继承父类，或实现一个接口。</li>
<li>匿名内部类不能是抽象类，因此必须实现抽象父类或接口中的所有抽象方法。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    foo.test();  <span class="comment">// 匿名内部类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3>
<p><strong>枚举</strong>的定义格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] <span class="keyword">enum</span> 枚举名 &#123;</span><br><span class="line">  <span class="comment">// 第一行列出所有实例</span></span><br><span class="line">  <span class="comment">// 可以定义 5 大成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修饰符</strong>只能为<code>public</code>。</p>
<p>枚举类与普通类的区别：</p>
<ul>
<li><strong>枚举</strong>默认已经继承<code>Enum</code>类，无法继承其他类。</li>
<li><strong>枚举</strong>要么是<code>final</code>类，要么是<code>abstract</code>类。且
Java
会自动判断该类为<code>final</code>类还是<code>abstract</code>类。</li>
<li><strong>枚举</strong>要求在开头列出所有实例</li>
</ul>
<p><strong>枚举类</strong>默认拥有以下方法：</p>
<ul>
<li><code>static Weekday[] values()</code>: 返回所有枚举实例</li>
<li><code>static Weekday valueOf(String)</code>：根据枚举名返回枚举实例</li>
<li><code>String name()</code>：返回枚举实例的名称</li>
<li><code>int ordinal()</code>：返回枚举实例的序号</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT; <span class="comment">// 所有实例</span></span><br><span class="line"></span><br><span class="line">    Weekday() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我来自构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我来自枚举中的foo方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Weekday.WED);    <span class="comment">// WED</span></span><br><span class="line">        System.out.println(Arrays.toString(Weekday.values())); <span class="comment">// [SUN, MON, TUE, WED, THU, FRI, SAT]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">d1</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        System.out.println(d1.ordinal());   <span class="comment">// 0</span></span><br><span class="line">        System.out.println(d1.name());      <span class="comment">// SUN</span></span><br><span class="line">        d1.foo();  <span class="comment">// 我来自枚举中的foo方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">d2</span> <span class="operator">=</span> Weekday.valueOf(<span class="string">&quot;TUE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举与switch">枚举与<code>switch</code></h4>
<p><code>switch</code>语句可以与枚举共同使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> MON:</span><br><span class="line">            <span class="keyword">case</span> TUE:</span><br><span class="line">            <span class="keyword">case</span> WED:</span><br><span class="line">            <span class="keyword">case</span> THU:</span><br><span class="line">            <span class="keyword">case</span> FRI:</span><br><span class="line">                System.out.println(<span class="string">&quot;上班哦&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SAT:</span><br><span class="line">            <span class="keyword">case</span> SUN:</span><br><span class="line">                System.out.println(<span class="string">&quot;放假哦&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        day.info(); <span class="comment">// 放假哦</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举类与构造器">枚举类与构造器</h4>
<p><strong>枚举</strong>定义后本质为<code>public static final</code>的常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">  SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Weekday</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">SUN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">MON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">TUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">WED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">THU</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">FRI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Weekday</span> <span class="variable">SAT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weekday</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们可以自己手动编写构造器，其使用方式与正常类相似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">  SUN(<span class="literal">false</span>),</span><br><span class="line">  MON(<span class="literal">true</span>),</span><br><span class="line">  TUE(<span class="literal">true</span>),</span><br><span class="line">  WED(<span class="literal">true</span>),</span><br><span class="line">  THU(<span class="literal">true</span>),</span><br><span class="line">  FRI(<span class="literal">true</span>),</span><br><span class="line">  SAT(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isWorkday;</span><br><span class="line"></span><br><span class="line">  Weekday(<span class="type">boolean</span> isWorkday) &#123;  <span class="comment">// private 构造器</span></span><br><span class="line">    <span class="built_in">this</span>.isWorkday = isWorkday;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="n-more-things">N More Things</h2>
<h3 id="记录类">记录类</h3>
<p><strong>记录类</strong>(<strong>Record</strong>)是从 Java 16
正式引入的类型( <a href="https://openjdk.java.net/jeps/395">JEP 395</a>
)。记录类会自动地为其添加<strong>有参构造</strong>、<strong>Getter</strong>、<code>toString</code>、<code>equals</code>和<code>hashCode</code>方法。</p>
<p>在 Java 16 之前，定义一个纯数据类可能需要如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">other</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">    <span class="keyword">return</span> other.x == x &amp;&amp; other.y == y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(x, y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%d, y=%d]&quot;</span>, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而引入<code>Record</code>类以后，该类可以简化为如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当然，<code>Record</code>类能做的事不止这些。具体可以阅读 <a
href="https://openjdk.java.net/jeps/395">JEP 395</a> 。</p>
<h3 id="形参个数可变方法">形参个数可变方法</h3>
<p>在 Java
中，方法可以有<strong>可变长</strong>参数。该参数位于某一方法的最后一位。</p>
<p>例如，如下定义了一个<strong>形参个数可变方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... sites)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法中，定义了一个<code>String</code>类型的可变长参数。可变长参数本质上是一个<strong>数组</strong>。<strong>可变长参数只能位于形参列表的最后一位！</strong></p>
<p>该方法可以通过如下方式调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">test(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;GitHub&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Bing&quot;</span>&#125;) <span class="comment">// 方法 1</span></span><br><span class="line">test(<span class="string">&quot;GitHub&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Bing&quot;</span>)  <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure>
<p><strong>使用<code>Type...</code>和<code>Type[]</code>的区别：前者可以通过两种方法调用，后者只能由方法
1 调用</strong></p>
<h3 id="java-8-函数式编程">Java 8 函数式编程</h3>
<p>见 <a href="/archives/java-functional-program">Java
函数式编程知识整理</a> 。</p>
<h3 id="java-9-接口的-private-方法">Java 9 接口的 private 方法</h3>
<p>Java 8 中<code>default</code>方法本质是<strong>实例方法</strong>。在
Java 9
之前定义默认方法时，如果某些方法有公共部分，需要多次编写相同的代码。Java
9
以后，可以将重复的代码抽离出来，独立成<code>private</code>方法，同时实现隐藏。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PrivateMethod</span> &#123;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    common();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    common();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 工具方法只被本类默认方法使用，并不希望暴露出去</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">common</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;公共部分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java-16-增强的-instanceof">Java 16 增强的 instanceof</h3>
<p>在 <a href="https://openjdk.java.net/jeps/394">JEP
394</a>中，<code>instanceof</code>运算符得到了升级。</p>
<p>从 Java 16
开始，可以通过<code>变量名 instanceof 类名 新变量名</code>判断该变量是否属于某个类的实例。如果属于，Java
将自动将其强制转换，并赋值到新的变量中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 16 之前</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 16 及以后</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，Java 16 增强的 instanceof 功能远远不止这些。具体阅读 <a
href="https://openjdk.java.net/jeps/394">JEP 394</a> 。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="https://union-click.jd.com/jdc?e=&amp;p=JF8BAMUJK1olXDYCV1pdAUoUB19MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksUB28BGlgRQl9HCANtdUpkA2twQgV1PE59KjxDcCNISg1pXVcZbQcyVF9cC04VBWsBHGslXQEyAjBdCUoWAm4NG14WbQcyVFlfC0oTAmYNGVoTWTYFVFdtUx55dQRLWCBQCXlcMgM9OHsnAF84K1slXjZAOlhYARtHBTtaHgsRXwNXA1cNC0hHBTwJGFkSDVJRB1ddOEkWAmsBKw">《疯狂
Java 讲义 · 第 5 版》</a></li>
<li><a href="https://bfw.h5.xeknow.com/s/1YClVz">跟着李刚老师学
Java（视频）</a></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程快速入门</title>
    <url>/archives/java-thread-qs/</url>
    <content><![CDATA[<p>多线程对于提高程序的并发有着十分重要的影响，本篇侧重于多线程的入门知识。</p>
<span id="more"></span>
<h2 id="几个概念">几个概念</h2>
<h3 id="进程">进程</h3>
<p>当一个程序运行时，该程序就变成操作系统中的一个<strong>进程</strong>。</p>
<p>进程一般包含以下特征：</p>
<ul>
<li><strong>独立性</strong>：进程时操作系统中独立存在的实体，它可以拥有自己独立的资源。每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间。</li>
<li><strong>动态性</strong>：进程与程序的区别在于，程序知识一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和不同的状态，这些概念在程序中都是不具备的。</li>
<li><strong>并发性</strong>：多个进程可以在单个处理器上并发执行，多个进程之间不会相互影响。</li>
</ul>
<h3 id="并发concurrent">并发（concurrent）</h3>
<p>多个任务在单个 CPU 上<strong>快速轮换</strong>执行，任意时刻，CPU
只能执行其中一个任务。但由于 CPU
会<strong>快速轮换</strong>地执行多个任务，因此用户感觉多个任务在同时执行
—— 用户的假象。</p>
<h3 id="并行parallel">并行（parallel）</h3>
<p>多 CPU 并行，多个任务真正的、同时在多个 CPU 同时执行。任意时刻，多个
CPU 能同时执行多个任务。并行是真正多任务同时执行。</p>
<h3 id="线程">线程</h3>
<p>线程是进程里的并发执行流，被称为<strong>轻量级进程</strong>。</p>
<p>Java 中的多线程有如下特点：</p>
<ul>
<li>线程不拥有独立的内存资源，只拥有栈、程序计数器，因此创建成本较小。</li>
<li>多线程共享进程的内存，因此多线程通信非常容易。</li>
</ul>
<h2 id="创建线程">创建线程</h2>
<h3 id="继承-thread-类">继承 Thread 类</h3>
<p>第一种方法是继承<code>Thread</code>类。主要有如下步骤：</p>
<ol type="1">
<li>继承<code>Thread</code>类，重写<code>run()</code>方法。</li>
<li>创建实例，并调用<code>start()</code>方法来启动线程。（<strong>注意不要调用<code>run()</code>方法！</strong>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      System.out.println(</span><br><span class="line">        Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">          Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如图所示（线程之间交替执行）：</p>
<img src="/archives/java-thread-qs/16362104651004.jpg" class="">
<h3 id="实现-runnable-接口">实现 Runnable 接口</h3>
<p>第二种方法是实现<code>Runnable</code>接口，效果与方法一一致。主要有如下步骤：</p>
<ol type="1">
<li>实现<code>Runnable</code>接口，重写<code>run()</code>方法。</li>
<li>创建实例。</li>
<li>以第二步的实例为
target，创建<code>Thread</code>对象，调用<code>start()</code>方法启动线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      System.out.println(</span><br><span class="line">        Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(t).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      System.out.println(</span><br><span class="line">        Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，因为<code>Runnable</code>接口是一个函数式接口，我们也可以直接使用<a
href="/archives/java-oop#匿名内部类">匿名内部类</a>、<a
href="/archives/java-functional-program">Lambda
表达式</a>创建线程，效果依然与方法一一致。这里以 Lambda 表达式为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">          Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      System.out.println(</span><br><span class="line">        Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现-callable-接口">实现 Callable 接口</h3>
<p><code>Callable</code>接口是<code>Runnable</code>接口的增强版，同样是函数式接口，与<code>Runnable</code>接口的区别如下：</p>
<ul>
<li><code>Callable</code>接口的<code>call()</code>方法有返回值；</li>
<li><code>Callable</code>接口的<code>call()</code>方法声明抛出 checked
异常，重写时亦可抛出异常。</li>
</ul>
<p>第三种实现<code>Callable</code>接口创建线程主要有如下步骤：</p>
<ol type="1">
<li>实现<code>Callable</code>接口，并重写<code>call()</code>方法；</li>
<li>创建实现类的实例；</li>
<li>将实例包装成<code>FutureTask</code>对象</li>
<li>以<code>FutureTask</code>实例为
target，创建<code>Thread</code>对象，调用<code>start()</code>方法启动线程。</li>
</ol>
<p>另外，可以使用<code>FutureTask</code>实例的<code>get()</code>方法来获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + j);</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">var</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(t);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(ft).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ft.get()); <span class="comment">// 获取返回值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ol type="1">
<li>Callable、FutureTask 的泛型必须一致，它们都指定了线程执行体（call
方法）的返回值。</li>
<li>如果程序要获取线程执行体（call
方法）的返回值，可调用<code>FutureTask</code>的<code>get()</code>方法来获取。<strong>一旦调用
get()方法，程序会要求先把该线程执行完成——线程体（call
方法）完成后才能得到返回值。</strong></li>
</ol>
<h3 id="三种线程创建方式的对比">三种线程创建方式的对比</h3>
<p>三种创建线程（可分为 2 类：一类是继承
Thread，另一类是实现接口）方式的对比：</p>
<p>实现接口主要有如下优势：</p>
<ol type="1">
<li>实现接口之后，线程体还可以继承其他父类；但如果已经继承
Thread，不能继承其他父类。</li>
<li>实现接口方式创建的线程，可以方便地使用线程池，性能更好。</li>
<li>对于继承 Thread
的方式创建线程类，每个线程都需要创建一个线程类的实例，从而造成数据逻辑与业务逻辑混杂。对于实现接口的方式，多个线程可共用同一个
target，数据逻辑与业务逻辑是分离的。</li>
</ol>
<p>继承<code>Thread</code>创建有下列优势：编程简单，适合初学者。</p>
<h2 id="线程的生命周期">线程的生命周期</h2>
<p>线程主要有如下生命周期：</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">生命周期</th>
<th style="text-align: left;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>新建</strong>(new)</td>
<td
style="text-align: left;">创建<code>Thread</code>类实例后，线程对象只是一个普通的
Java 对象，并不表现任何动态特征</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>就绪</strong>(ready)</td>
<td
style="text-align: left;">调用线程对象的<code>start()</code>方法，线程处于就绪状态</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>运行</strong>(running)</td>
<td style="text-align: left;">得到
CPU，线程开始执行。线程在执行过程中，会一直在<strong>就绪</strong>和<strong>运行</strong>之间切换</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>阻塞</strong>(blocked)</td>
<td style="text-align: left;">阻塞状态的线程无法继续执行</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>死亡</strong>(dead)</td>
<td style="text-align: left;">线程死亡</td>
</tr>
</tbody>
</table>
<img src="/archives/java-thread-qs/thread.drawio.png" class="">
<p><strong>注意</strong>：在正常开发过程中，<strong>不要</strong>使用<code>suspend</code>、<code>resume</code>、<code>stop</code>控制线程，否则可能引发<strong>死锁</strong>！</p>
<h2 id="join-线程与线程-sleep">join 线程与线程 sleep</h2>
<h3 id="join">join</h3>
<p>当一条线程执行到某个点，必须等待另外一个线程完成后才能继续向下执行时，应使用<code>join</code>来等待线程执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinThreadTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---&gt; &quot;</span> + i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---&gt; &quot;</span> + i);</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 i 为 20 时，等待线程执行</span></span><br><span class="line">        t.join();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">main ---&gt; 18</span><br><span class="line">main ---&gt; 19</span><br><span class="line">Thread-0 ---&gt; 12</span><br><span class="line">main ---&gt; 20 // 注意此处</span><br><span class="line">Thread-0 ---&gt; 13</span><br><span class="line">Thread-0 ---&gt; 14</span><br><span class="line">Thread-0 ---&gt; 15</span><br><span class="line">(Thread 执行)...</span><br><span class="line">Thread-0 ---&gt; 97</span><br><span class="line">Thread-0 ---&gt; 98</span><br><span class="line">Thread-0 ---&gt; 99</span><br><span class="line">main ---&gt; 21</span><br><span class="line">main ---&gt; 22</span><br><span class="line">(main 执行)...</span><br><span class="line">main ---&gt; 97</span><br><span class="line">main ---&gt; 98</span><br><span class="line">main ---&gt; 99</span><br></pre></td></tr></table></figure>
<h3 id="sleep">sleep</h3>
<p>使得<strong>当前运行的线程</strong>暂停、进入阻塞一段时间，<code>sleep</code>常常用于控制程序的暂停，十分可靠。</p>
<p><code>Thread.sleep(long)</code>在哪个线程中执行，就让哪个线程暂停。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepThreadTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>); <span class="comment">// 暂停 5 秒</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">main ---&gt; 0</span><br><span class="line">main ---&gt; 1</span><br><span class="line">...</span><br><span class="line">main ---&gt; 19</span><br><span class="line">main ---&gt; 20</span><br><span class="line">(暂停 5 秒)</span><br><span class="line">main ---&gt; 21</span><br><span class="line">main ---&gt; 22</span><br><span class="line">...</span><br><span class="line">main ---&gt; 98</span><br><span class="line">main ---&gt; 99</span><br></pre></td></tr></table></figure>
<h2 id="后台进程">后台进程</h2>
<p><strong>后台线程</strong>（<strong>Daemon
Thread</strong>，又称<strong>守护线程</strong>）主要是为其他线程提供服务。前台线程全部死亡时，那么后台线程会自动死亡。JVM
中 GC 线程是典型的后台线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ------&gt; &quot;</span> + ++i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码未将线程<code>t</code>设为后台线程，运行该程序时，程序将一直运行（无限循环）。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Thread-0 ------&gt; 1</span><br><span class="line">Thread-0 ------&gt; 2</span><br><span class="line">Thread-0 ------&gt; 3</span><br><span class="line">Thread-0 ------&gt; 4</span><br><span class="line">Thread-0 ------&gt; 5</span><br><span class="line">...无限循环</span><br></pre></td></tr></table></figure>
<p>主要有两种方式来产生后台线程：</p>
<ul>
<li><p>后台线程启动的线程默认为后台线程。</p></li>
<li><p>调用<code>setDaemon</code>方法。</p>
<p>在启动线程（即调用<code>start</code>方法）之前调用<code>setDaemon</code>方法后，该线程即被设置为守护线程。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ------&gt; &quot;</span> + ++i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);  <span class="comment">// 将线程设为后台线程</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该程序，程序无任何输出即停止。（或者看到很少的输出……）</p></li>
</ul>
<h2 id="线程优先级">线程优先级</h2>
<p>如果一个线程的优先级越高，那么该线程可以获得更多的执行机会。</p>
<p>执行<code>setPriority(int)</code>方法即可改变该线程的优先级。参数值范围为
1 - 10，但并不是所有操作系统都支持 10
个优先级。通常只使用<code>MIN_PRIORITY</code>（1）、<code>NORM_PRIORITY</code>（5）、<code>MAX_PRIORITY</code>（10）这三个优先级。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="https://union-click.jd.com/jdc?e=&amp;p=JF8BAMUJK1olXDYCV1pdAUoUB19MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksUB28BGlgRQl9HCANtdUpkA2twQgV1PE59KjxDcCNISg1pXVcZbQcyVF9cC04VBWsBHGslXQEyAjBdCUoWAm4NG14WbQcyVFlfC0oTAmYNGVoTWTYFVFdtUx55dQRLWCBQCXlcMgM9OHsnAF84K1slXjZAOlhYARtHBTtaHgsRXwNXA1cNC0hHBTwJGFkSDVJRB1ddOEkWAmsBKw">《疯狂
Java 讲义 · 第 5 版》</a></li>
<li><a href="https://bfw.h5.xeknow.com/s/1YClVz">跟着李刚老师学
Java（视频）</a></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程——线程安全</title>
    <url>/archives/java-thread-safety/</url>
    <content><![CDATA[<p>本文主要介绍 Java 多线程安全问题的内容。</p>
<span id="more"></span>
<h2 id="线程安全问题引入">线程安全问题引入</h2>
<p>银行取钱问题：假设允许在同一时间多个人从统一账户上取钱。</p>
<p>正如在 <a href="/archives/java-thread-qs/" title="Java 多线程快速入门">上一篇</a> 中所讲：</p>
<blockquote>
<p>多个任务在单个 CPU 上 <strong>快速轮换</strong> 执行，任意时刻，CPU
只能执行其中一个任务。但由于 CPU 会 <strong>快速轮换</strong>
地执行多个任务，因此用户感觉多个任务在同时执行 —— 用户的假象。</p>
</blockquote>
<p>CPU
在某一时刻只能执行一个任务，多个任务之间快速切换。那么就可能出现一种情况：</p>
<p>A、B 同时去银行取 800 元，银行卡上的余额为 1,000 元。</p>
<ol type="1">
<li>两人同时进入银行取钱</li>
<li>系统判断要取的钱都是够的</li>
<li>CPU 处理 B 的请求：吐 800 块钱、扣余额，完成</li>
<li>CPU 继续处理 A
的请求。因为已经完成了余额的判断，所以直接进行吐钱、扣余额。</li>
</ol>
<p>到这里，整个流程就完成了。但是有问题：</p>
<ul>
<li>吐了 1,600 块钱</li>
<li>余额剩下 -600 元了</li>
</ul>
<p>这便是一个典型的线程安全问题。</p>
<p>对应出来的代码可以如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentSafety</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>(account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>(account, <span class="number">800</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Account account;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> amount;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Account account, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.account = account;</span><br><span class="line">    <span class="built_in">this</span>.amount = amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (account.getBalance() &gt;= amount) &#123;</span><br><span class="line">      System.out.printf(<span class="string">&quot;[%s] Withdraw %d\n&quot;</span>, Thread.currentThread(), amount);</span><br><span class="line">      account.withdraw(amount);</span><br><span class="line">      System.out.printf(<span class="string">&quot;[%s] Balance is now %d\n&quot;</span>, Thread.currentThread(), account.getBalance());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.printf(<span class="string">&quot;[%s] Not enough money\n&quot;</span>, Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = balance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    balance -= amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[Thread[Thread-0,5,main]] Withdraw 800</span><br><span class="line">[Thread[Thread-0,5,main]] Balance is now 200</span><br><span class="line">[Thread[Thread-1,5,main]] Withdraw 800</span><br><span class="line">[Thread[Thread-1,5,main]] Balance is now -600</span><br></pre></td></tr></table></figure>
<h2 id="同步代码块">同步代码块</h2>
<p>同步代码块常常用于维护数据的一致性。其机制是给共享资源上锁，只有拿到锁的线程才能够访问共享资源。该锁是隐式的，不需要我们进行维护。同步代码块的处理是由
JVM 进行完成。</p>
<p>同步代码块的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (同步监视器) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，同步监视器需要设置为
<strong>多个线程之间相互争抢的资源</strong>，在如上的例子中即为
<code>account</code>。</p>
<p>将线程的 <code>run</code> 方法改为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">    <span class="keyword">if</span> (account.getBalance() &gt;= amount) &#123;</span><br><span class="line">      System.out.printf(<span class="string">&quot;[%s] Withdraw %d\n&quot;</span>, Thread.currentThread(), amount);</span><br><span class="line">      account.withdraw(amount);</span><br><span class="line">      System.out.printf(<span class="string">&quot;[%s] Balance is now %d\n&quot;</span>, Thread.currentThread(), account.getBalance());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.printf(<span class="string">&quot;[%s] Not enough money\n&quot;</span>, Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时结果永远是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[Thread[Thread-0,5,main]] Withdraw 800</span><br><span class="line">[Thread[Thread-0,5,main]] Balance is now 200</span><br><span class="line">[Thread[Thread-1,5,main]] Not enough money</span><br></pre></td></tr></table></figure>
<p>注意：无论在同步代码块中执行什么语句，都必须等到语句块结束才会将锁释放。</p>
<h2 id="同步方法">同步方法</h2>
<p>同步方法是使用 <code>synchronized</code>
修饰的方法，整个该方法都是同步代码。</p>
<p>如果该方法是实例方法，那么同步监视器是当前对象。如果是类方法，同步监视器则为类本身。</p>
<p>同步方法与同步代码块的区别：同步代码块需要显式指定同步监视器，同步方法不需要。</p>
<p>仍然以取钱例子为例，因为同步方法的同步监视器是该类实例或者类本身，我们可以将取钱的业务逻辑直接修改到类中。</p>
<p>故代码可以改为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentSafety</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>(account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>(account, <span class="number">800</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Account account;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> amount;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Account account, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.account = account;</span><br><span class="line">    <span class="built_in">this</span>.amount = amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    account.withdraw(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = balance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= amount) &#123;</span><br><span class="line">      System.out.printf(<span class="string">&quot;[%s] Withdraw %d\n&quot;</span>, Thread.currentThread(), amount);</span><br><span class="line">      balance -= amount;</span><br><span class="line">      System.out.printf(<span class="string">&quot;[%s] Balance is now %d\n&quot;</span>, Thread.currentThread(), balance);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.printf(<span class="string">&quot;[%s] Not enough money\n&quot;</span>, Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后的结果与同步代码块相似：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[Thread[Thread-0,5,main]] Withdraw 800</span><br><span class="line">[Thread[Thread-0,5,main]] Balance is now 200</span><br><span class="line">[Thread[Thread-1,5,main]] Not enough money</span><br></pre></td></tr></table></figure>
<h2 id="使用-lock">使用 Lock</h2>
<p>同步代码块、同步方法都是由 JDK 来自动管理锁。当然，我们也可以自己使用
Lock 来管理锁。</p>
<p>Java 在 <code>java.util.concurrent.locks</code> 包下有个
<code>Lock</code> 接口，主要有 3
个实现类：<code>ReentrantLock</code>、<code>ReentrantReadWriteLock.ReadLock</code>、<code>ReentrantReadWriteLock.WriteLock</code>。在这里我们以
<code>ReentrantLock</code> 作为演示。</p>
<p>在 <code>Account</code> 类中，我们可以添加一个 Lock
的成员变量，作为锁。在进行取钱操作之前，我们首先对其进行锁定。操作完成后，即可对锁进行释放。注意，为保证锁一定被释放，可以将解锁的语句放在
<code>try</code> 的 <code>finally</code> 块中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = balance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (balance &gt;= amount) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%s] Withdraw %d\n&quot;</span>, Thread.currentThread(), amount);</span><br><span class="line">        balance -= amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%s] Balance is now %d\n&quot;</span>, Thread.currentThread(), balance);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%s] Not enough money\n&quot;</span>, Thread.currentThread());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 确保永远释放锁</span></span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果与之前完全一致。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 Stream 知识整理</title>
    <url>/archives/java8-stream/</url>
    <content><![CDATA[<p>Java 8 的 Stream，又一个非常好用的特性。</p>
<span id="more"></span>
<h2 id="综述">综述</h2>
<p>Java 8 新增了 <strong>Stream API</strong>。<strong>Stream
API</strong>有点类似使用<strong>SQL
语句</strong>，可以将<strong>集合</strong>中的元素进行过滤。使用时，类似于从一个管道中抽取元素，并对他们进行操作。使用流的一个优点是，他可以使得我们的程序更小，并且更容易理解。</p>
<p>与<strong>Stream
API</strong>相关的接口有<code>Stream</code>、<code>IntStream</code>,
<code>LongStream</code>, <code>DoubleStream</code>（因为 Java
的泛型不支持基本数据类型，而又因频繁的装箱、拆箱存在效率问题，故额外有后三者）。</p>
<p>使用<code>Stream</code>操作时，我们通常使用<strong>链式操作</strong>，即将多条代码合并成一条代码（事例将在<strong>使用<code>Supplier</code>创建</strong>中给出）。</p>
<h2 id="java-collection-体系数据处理的演进">Java Collection
体系数据处理的演进</h2>
<p>本小节用于测试的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">User</span><span class="params">(Integer id, String name, Integer money)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">var</span> <span class="variable">users</span> <span class="operator">=</span> Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">200</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">200</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">10000</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">20000</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">5</span>, <span class="string">&quot;王强&quot;</span>, <span class="number">80000</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="通过不同方法来过滤不同数据">通过不同方法来过滤不同数据</h3>
<p>我们过滤数据首先想到的方法是针对各个需求来定义一个个的方法。</p>
<p>例如，产品经理给了你一个<strong>筛选出所有 id 大于 3
用户</strong>的需求，可以定义如下<code>getIdGreaterThan3</code>的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// users 定义</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newUsers</span> <span class="operator">=</span> getIdGreaterThan3(users);</span><br><span class="line">        <span class="keyword">for</span> (User user : newUsers) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title function_">getIdGreaterThan3</span><span class="params">(List&lt;User&gt; users)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newUsers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.id() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                newUsers.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUsers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  输出：</span></span><br><span class="line"><span class="comment">  User[id=4, name=赵六, money=20000]</span></span><br><span class="line"><span class="comment">  User[id=5, name=王强, money=80000]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>第二天，产品经理要求你<strong>筛选出所有姓“王”的用户</strong>的需求，定义<code>getAllWang</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// users 定义</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newUsers</span> <span class="operator">=</span> getAllWang(users);</span><br><span class="line">        <span class="keyword">for</span> (User user : newUsers) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title function_">getAllWang</span><span class="params">(List&lt;User&gt; users)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newUsers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.name().startsWith(<span class="string">&quot;王&quot;</span>)) &#123;</span><br><span class="line">                newUsers.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUsers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  输出：</span></span><br><span class="line"><span class="comment">  User[id=3, name=王五, money=10000]</span></span><br><span class="line"><span class="comment">  User[id=5, name=王强, money=80000]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>第三天，产品经理要求你开发<strong>所有钱大于 10000
的用户</strong>的需求，你瞅了瞅他，写出了如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// users 定义</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newUsers</span> <span class="operator">=</span> getRichPeople(users);</span><br><span class="line">        <span class="keyword">for</span> (User user : newUsers) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title function_">getRichPeople</span><span class="params">(List&lt;User&gt; users)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newUsers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.money() &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">                newUsers.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUsers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  输出：</span></span><br><span class="line"><span class="comment">  User[id=4, name=赵六, money=20000]</span></span><br><span class="line"><span class="comment">  User[id=5, name=王强, money=80000]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>此时此刻，你会发现我们似乎写了<strong>很多</strong>重复的方法...</p>
<h3 id="使用接口来代替重复操作">使用接口来代替重复操作</h3>
<p>在 Java
世界中，对于相似的操作我们通常使用接口定义，对于不同的操作我们相应的定义不同的实现类来实现不同的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// users 定义</span></span><br><span class="line">        <span class="keyword">for</span> (User user : getUsers(users, <span class="keyword">new</span> <span class="title class_">JudgeIdGreaterThan3</span>())) &#123;</span><br><span class="line">            <span class="comment">// 判断ID是否大于3</span></span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : getUsers(users, <span class="keyword">new</span> <span class="title class_">JudgeIsWang</span>())) &#123;</span><br><span class="line">            <span class="comment">// 判断是否姓王</span></span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : getUsers(users, <span class="keyword">new</span> <span class="title class_">JudgeIsRich</span>())) &#123;</span><br><span class="line">            <span class="comment">// 判断是否有钱</span></span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(List&lt;User&gt; users, Judge condition)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newUsers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (condition.test(user)) &#123;</span><br><span class="line">                newUsers.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUsers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JudgeIdGreaterThan3</span> <span class="keyword">implements</span> <span class="title class_">Judge</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> user.id() &gt; <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JudgeIsWang</span> <span class="keyword">implements</span> <span class="title class_">Judge</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> user.name().startsWith(<span class="string">&quot;王&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JudgeIsRich</span> <span class="keyword">implements</span> <span class="title class_">Judge</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> user.money() &gt; <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Judge</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(User user)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以使用<strong>匿名内部类</strong>来实现同样的功能。</p>
<h3 id="使用-java-8-提供的predicate接口">使用 Java 8
提供的<code>Predicate</code>接口</h3>
<p>事实上，从 Java 8 开始，JDK
提供了一个名为<code>Predicate</code>的<strong>接口</strong>，其作用与上方自己写的<code>Judge</code>接口类似。同时，因为它是<strong>函数式接口</strong>，我们可以很轻松地使用
Lambda 表达式。</p>
<img src="/archives/java8-stream/16374142332314.jpg" class="">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// users 定义</span></span><br><span class="line">        <span class="keyword">for</span> (User user : getUsers(users, user -&gt; user.id() &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="comment">// 判断ID是否大于3</span></span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : getUsers(users, user -&gt; user.name().startsWith(<span class="string">&quot;王&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 判断是否姓王</span></span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : getUsers(users, user -&gt; user.money() &gt; <span class="number">10000</span>)) &#123;</span><br><span class="line">            <span class="comment">// 判断是否有钱</span></span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(List&lt;User&gt; users, Predicate&lt;User&gt; condition)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">newUsers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (condition.test(user)) &#123;</span><br><span class="line">                newUsers.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUsers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>从最初编写一个一个独立的方法，到后面自行开发接口逐步地通用化，再到使用
Lambda 表达式，我们重复的工作被逐步逐步地简化。</p>
<p>事实上，在 Java
推出<code>Predicate</code>接口，开源世界早已对于集合操作有了简化。例如以
<a href="https://guava.dev/">Google Guava</a> 为代表的第三方框架，以及以
<a href="http://www.groovy-lang.org/">Groovy</a> 、 <a
href="https://scala-lang.org/">Scala</a> 、 <a
href="https://kotlinlang.org/">Kotlin</a> 为代表的编程语言。</p>
<h2 id="steam-核心知识">Steam 核心知识</h2>
<h3 id="创建-stream">创建 Stream</h3>
<h4 id="使用-stream.of-创建">使用 Stream.of() 创建</h4>
<p>最简单的方法是使用<code>Stream.of()</code>来创建 Stream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; foo = Stream.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line">foo.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个由 4
个编程语言组成的流，并使用<code>forEach()</code>方法将其打印出来（<code>forEach</code>方法的参数为<code>Consumer&lt;T&gt;</code>函数式接口，可直接使用
<a href="/archives/java-functional-program/">Lambda 表达式</a> ）</p>
<h4 id="使用数组创建">使用数组创建</h4>
<p>使用数组创建 Stream
可以使用<code>Arrays.stream()</code>方法来创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] foo = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; bar = Arrays.stream(foo);</span><br><span class="line">bar.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="使用集合框架创建">使用集合框架创建</h4>
<p>同样，Stream
也可以基于集合框架来创建，<code>Collection</code>接口提供了<code>stream()</code>的抽象方法，使得<code>Set</code>、<code>List</code>、<code>Map</code>等集合拥有创建
Stream 的能力。</p>
<p>这里以 <code>List</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; foo = List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; bar = foo.stream();</span><br><span class="line">bar.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="使用supplier创建">使用<code>Supplier</code>创建</h4>
<p>我们也可以通过<code>Stream.generate(Supplier&lt;? extends T&gt; s)</code>方法来创建
Stream。这里参数要求为<code>Supplier</code>，它同样是个函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下事例均使用`链式操作`</span></span><br><span class="line">Stream.generate(() -&gt; <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>))</span><br><span class="line">      .limit(<span class="number">10</span>)   <span class="comment">// 此处使用`limit`来闲置元素个数</span></span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="中间操作">中间操作</h3>
<p><strong>中间操作</strong>是指调用方法以后，仍然返回<code>Stream</code>对象。Java
Stream 中，允许有多个<strong>中间操作</strong>。</p>
<h4 id="map">map</h4>
<p><code>Stream.map(Function&lt;? super T,​? extends R&gt; mapper)</code>是将一个某个操作映射到
Stream 中每个元素上。同样，<code>map</code>的参数为函数式接口。</p>
<p>例如，如下代码实现了对于每个元素进行平方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">      .map(i -&gt; i * i)</span><br><span class="line">      .forEach(System.out::println);   <span class="comment">// 1, 4, 9, 16, 25</span></span><br></pre></td></tr></table></figure>
<p><code>map</code>方法也可以对于元素中的对象进行操作，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)     <span class="comment">// 将元素转为大写</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="filter">filter</h4>
<p><code>Stream.filter​(Predicate&lt;? super T&gt; predicate)</code>可以对于
Stream 中元素进行过滤。</p>
<p>例如，以下代码将一组数字中所有偶数打印出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">         .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">         .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>如果 Stream
中元素为对象，同样可以进行过滤。例如，如下代码实现了将年龄为 18
岁以下的未成年人过滤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123; &#125; <span class="comment">// 需要使用 Java 16 及以上版本</span></span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; peoples = List.of(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">16</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王强&quot;</span>, <span class="number">22</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小宋&quot;</span>, <span class="number">8</span>)</span><br><span class="line">);</span><br><span class="line">peoples.stream()</span><br><span class="line">       .filter(it -&gt; it.age() &gt;= <span class="number">18</span>)</span><br><span class="line">       .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Person[name=张三, age=30]</span></span><br><span class="line"><span class="comment">Person[name=王五, age=18]</span></span><br><span class="line"><span class="comment">Person[name=王强, age=22]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="parallel">parallel</h4>
<p>通常情况下，对 Stream
的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以并行处理
Stream
的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123; &#125; <span class="comment">// 需要使用 Java 16 及以上版本</span></span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; peoples = List.of(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">16</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王强&quot;</span>, <span class="number">22</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小宋&quot;</span>, <span class="number">8</span>)</span><br><span class="line">);</span><br><span class="line">peoples.stream()</span><br><span class="line">       .parallel()  <span class="comment">// 将普通 stream 转换为并行 stream</span></span><br><span class="line">       .filter(it -&gt; it.age() &gt;= <span class="number">18</span>)    <span class="comment">// 并行筛选</span></span><br><span class="line">       .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="sorted">sorted</h4>
<p><code>Stream.sorted()</code>可以实现对 Stream
中元素进行排序，所排序的元素必须实现<code>Comparable</code>。当然也可以在参数中填入自己的<code>Comparator</code>。</p>
<p>如下代码对随机数进行从小到大的排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.of(<span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">         .sorted()</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：0 2 3 5 6 7 9</span></span><br></pre></td></tr></table></figure>
<h4 id="distinct">distinct</h4>
<p><code>Stream.distinct()</code>可以对于 Stream 中的元素进行去重：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.of(<span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">         .distinct()</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：5 8 3 4 6 9 7</span></span><br></pre></td></tr></table></figure>
<h4 id="skip">skip</h4>
<p><code>Stream.skip()</code>可以对于 Stream 中前几个元素进行跳过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">         .skip(<span class="number">3</span>)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>
<h4 id="limit">limit</h4>
<p><code>Stream.limit()</code>可以只保留前几个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">         .limit(<span class="number">5</span>)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<h4 id="concat">concat</h4>
<p><code>Stream.concat()</code>用于将两个 Stream 合并：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">foo</span> <span class="operator">=</span> IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">bar</span> <span class="operator">=</span> IntStream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">IntStream.concat(foo, bar)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>
<h3 id="终结操作">终结操作</h3>
<p><strong>终结操作</strong>是指调用方法后，返回非<code>Stream</code>的操作，包括<code>void</code>。Java
Stream 中，<strong>只允许有一个终结操作</strong>。</p>
<p><strong>终结操作</strong>主要有如下方法：</p>
<ul>
<li><p><code>forEach</code>：对于<code>Stream</code>中每个元素进行遍历，常见用途如打印元素。</p></li>
<li><p><code>count</code>/<code>max</code>/<code>min</code>：返回<strong>元素个数</strong>/<strong>最大值</strong>/<strong>最小值</strong>。</p></li>
<li><p><code>anyMatch</code>/<code>allMatch</code>/<code>noneMatch</code>：<strong>任意一个符合</strong>/<strong>全部符合</strong>/<strong>都不符合</strong>给定的<code>Predicate</code>条件返回<code>true</code>。</p></li>
<li><p><code>findFirst</code>/<code>findAny</code>：返回流中<strong>第一个</strong>/<strong>任意一个</strong>元素。</p></li>
<li><p>🌟<code>collect</code>：<strong>几乎</strong>可以将一个<code>Stream</code>对象转换为任何内容，例如以下代码可以将姓王的用户筛选出来，并转换为
List 集合。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">var</span> <span class="variable">ls</span> <span class="operator">=</span> users.stream()</span><br><span class="line">     .filter(it -&gt; it.name().startsWith(<span class="string">&quot;王&quot;</span>))</span><br><span class="line">     .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>
<p>因为<code>collect</code>方法较为复杂，有兴趣可以自行阅读 JDK
文档。</p></li>
</ul>
<h2 id="idea-流调试器">IDEA 流调试器</h2>
<p>IDEA 中内置了一个名为<strong>Java Stream
Debugger</strong>插件（如果没有请确保自己为最新版的 IDEA，或者尝试前往
IDEA 插件市场安装），该插件可以通过可视化的方式直观地看到 Stream
的处理过程。</p>
<p>使用方式：</p>
<ol type="1">
<li><p>在 Stream 流中打上断点；</p></li>
<li><p>启动 Debug 模式；</p></li>
<li><p>断点暂停后，点击 Debug 面板上的<strong>Trace Current Stream
Chain</strong>按钮（如图所示）</p>
<img src="/archives/java8-stream/16373728293511.jpg" class=""></li>
</ol>
<p>该插件可以分步地将 Stream
操作以可视化的形式呈现出来（当然也可以通过下方的<strong>Flat
Mode</strong>按钮在同一个窗口中看到所有操作）</p>
<img src="/archives/java8-stream/16373728823304.jpg" class="">
<img src="/archives/java8-stream/16373729705219.jpg" class="">
<h3 id="演示-1---filter">演示 1 - filter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">User</span><span class="params">(Integer id, String name, Integer money)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">users</span> <span class="operator">=</span> Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">200</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">200</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">10000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">20000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">5</span>, <span class="string">&quot;王强&quot;</span>, <span class="number">80000</span>)</span><br><span class="line">        );</span><br><span class="line">        users.stream()</span><br><span class="line">                .filter(it -&gt; it.money() &gt; <span class="number">10000</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/archives/java8-stream/16373731272913.jpg" class="">
<h3 id="演示-2---distinct">演示 2 - distinct</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/archives/java8-stream/16373734336456.jpg" class="">
<h3 id="演示-3---sorted">演示 3 - sorted</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .sorted()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/archives/java8-stream/16373736982517.jpg" class="">
<h3 id="演示-4---map">演示 4 - map</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">User</span><span class="params">(Integer id, String name, Integer money)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">users</span> <span class="operator">=</span> Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">200</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">200</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">10000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">20000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">5</span>, <span class="string">&quot;王强&quot;</span>, <span class="number">80000</span>)</span><br><span class="line">        );</span><br><span class="line">        users.stream()</span><br><span class="line">                .filter(it -&gt; it.name().startsWith(<span class="string">&quot;王&quot;</span>))</span><br><span class="line">                .map(User::name)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/archives/java8-stream/16373757675756.jpg" class="">
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322402873081889">使用
Stream —— 廖雪峰</a></li>
<li><a
href="https://xiedaimala.com/tasks/1a1a8ea8-4c7a-4bb1-9337-b10296004f05/video_tutorials/fb2ecfc0-216c-41d8-9bb4-04a744f31f39">Collection
与 Stream 的前世今生</a></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>JAX-RS 入门</title>
    <url>/archives/jaxrs-101/</url>
    <content><![CDATA[<p>JAX-RS 是 Jakarta RESTful Web Services 的缩写，是 Jakarta EE API
规范，用于构建 RESTful 风格的 Web 服务。</p>
<p>本文通过一个简单的内存版的用户管理系统，介绍 JAX-RS 的基本用法。</p>
<span id="more"></span>
<h2 id="使用-quarkus-rest-创建-jax-rs-服务">使用 Quarkus REST 创建
JAX-RS 服务</h2>
<p>为了便于演示，我们使用 Quarkus REST 来创建 JAX-RS 服务。</p>
<img src="/archives/jaxrs-101/quarkus-create.png" class="">
<h2 id="jax-rs-常用注解">JAX-RS 常用注解</h2>
<ul>
<li><code>@Path</code>：指定资源类或方法的路径。</li>
<li><code>@GET</code>：指定方法可以通过 GET 方法访问。</li>
<li><code>@POST</code>：指定方法可以通过 POST 方法访问。</li>
<li><code>@PUT</code>：指定方法可以通过 PUT 方法访问。</li>
<li><code>@DELETE</code>：指定方法可以通过 DELETE 方法访问。</li>
<li><code>@PATCH</code>：指定方法可以通过 PATCH 方法访问。</li>
<li><code>@Consumes</code>：指定方法可以接受的 MIME 类型。</li>
<li><code>@Produces</code>：指定方法可以生成的 MIME 类型。</li>
</ul>
<h2 id="用户实体类">用户实体类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getter and setter...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dao-类">DAO 类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">updateUser</span><span class="params">(Integer id, User user)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(Integer id)</span>;</span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(Integer id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处我们使用一个 <code>List</code> 来模拟数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (users.stream().anyMatch(u -&gt; u.getId().equals(user.getId()))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        users.add(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateUser</span><span class="params">(Integer id, User user)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (users.get(i).getId().equals(id)) &#123;</span><br><span class="line">                users.set(i, user);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> users.removeIf(u -&gt; u.getId().equals(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> users.stream().filter(u -&gt; u.getId().equals(id)).findFirst().orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="userresource-类"><code>UserResource</code> 类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Path(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="meta">@Consumes(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserResource</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.ok(userDao.getUsers()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="meta">@Path(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathParam(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.getUser(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(Response.Status.NOT_FOUND).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response.ok(user).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userDao.addUser(user);</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(Response.Status.CONFLICT).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response.ok(u).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PUT</span></span><br><span class="line">    <span class="meta">@Path(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathParam(&quot;id&quot;)</span> Integer id, User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!userDao.updateUser(id, user)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(Response.Status.NOT_FOUND).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DELETE</span></span><br><span class="line">    <span class="meta">@Path(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathParam(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!userDao.deleteUser(id)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(Response.Status.NOT_FOUND).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码仓库：<a href="https://github.com/gtn1024/jaxrs-demo"
class="uri">https://github.com/gtn1024/jaxrs-demo</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jakarta EE</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 基础 - 初识 JVM</title>
    <url>/archives/jvm-basic-1/</url>
    <content><![CDATA[<p>本文主要讲解 Java 虚拟机的基础，以及字节码相关知识。</p>
<span id="more"></span>
<h2 id="jvm-是什么">JVM 是什么</h2>
<p>JVM 全称是 Java Virtual Machine，中文名为 Java
虚拟机，是一个运行在计算机上的程序，他的职责是运行 Java 字节码文件。</p>
<h2 id="jvm-的功能">JVM 的功能</h2>
<ol type="1">
<li><p>解释和运行</p>
<ul>
<li>对字节码文件中的指令，实时的解释成机器码，让计算机执行</li>
</ul></li>
<li><p>内存管理</p>
<ul>
<li>自动为对象、方法等奉陪内存</li>
<li>自动的垃圾回收机制，回收不再使用的内存</li>
</ul></li>
<li><p>即时编译</p>
<ul>
<li>对热点代码进行优化，提升执行效率</li>
</ul></li>
</ol>
<h3 id="即时编译">即时编译</h3>
<img src="/archives/jvm-basic-1/20241021213823.png" class="">
<p>JVM 提供了 即时编译（JIT）进行性能优化。最终能达到接近 C/C++
语言的运行性能。在特定场景下甚至实现超越。</p>
<h2 id="jvm-的组成">JVM 的组成</h2>
<img src="/archives/jvm-basic-1/jvm-container.drawio.png" class="">
<h2 id="字节码文件的组成">字节码文件的组成</h2>
<p>字节码文件主要由如下 5 个部分组成：</p>
<ul>
<li>基本信息：魔数、字节码文件对应的 Java
版本号、访问标识、父类和接口</li>
<li>常量池：保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用</li>
<li>字段：当前类或接口声明的字段信息</li>
<li>方法：当前类或接口声明的方法信息、字节码指令</li>
<li>属性：类的属性，比如源码的文件名、内部类的列表等</li>
</ul>
<h3 id="基本信息">基本信息</h3>
<p><strong>魔数</strong>：4 字节，用于标识文件类型，固定值
<code>0xCAFEBABE</code></p>
<img src="/archives/jvm-basic-1/class-magic-num.png" class="">
<p><strong>主副版本号</strong>：主副版本号是指编译字节码文件的 JDK
版本号。比如 JDK 1.8 编译的字节码文件，主版本号是 52，副版本号是 0；JDK
21 的主版本号是 65，副版本号是 0。一般只需要关心主版本号。在 JDK 1.2
之后大版本的计算方法是
<code>主版本号 - 44</code>。其主要作用是用来判断当前字节码的版本和运行时的
JDK 是否兼容。</p>
<img src="/archives/jvm-basic-1/jclasslib.png" class="">
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - 缓存穿透</title>
    <url>/archives/redis-cache-penetration/</url>
    <content><![CDATA[<p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。最终造成服务宕机。</p>
<p>例如，某位黑客故意制造了大量无效的 id
发往服务端，使得大量请求落到数据库上，数据库也没有查到对应的数据，此操作对于数据库造成了大量的压力。</p>
<span id="more"></span>
<img src="/archives/redis-cache-penetration/20240717184945.png" class="">
<p>主要有如下方法解决：</p>
<ol type="1">
<li>数据格式校验</li>
<li>缓存空对象</li>
<li>布隆过滤</li>
<li>接口限流</li>
</ol>
<h2 id="数据格式校验">数据格式校验</h2>
<p>例如，对于
ID，检验是否为正整数；对于邮箱、手机号等数据，做好校验。</p>
<h2 id="缓存空对象">缓存空对象</h2>
<p>如果数据库访问到空值，将该空值也存到 redis 里。</p>
<p>优点：实现简单，维护方便</p>
<p>缺点： - 额外内存消耗（加入较短的 TTL 缓解） -
可能造成短期的不一致（TTL 缓解，或主动失效缓存）</p>
<img src="/archives/redis-cache-penetration/20240717195648.png" class="">
<h2 id="布隆过滤">布隆过滤</h2>
<img src="/archives/redis-cache-penetration/20240717195802.png" class="">
<p>优点：内存占用少，没有多余的 key</p>
<p>缺点：</p>
<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
<h2 id="接口限流">接口限流</h2>
<p>对用户或者 IP
进行限流，对于恶意用户，可以采取黑名单的方式禁止访问接口。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 入门 —— Redis 数据类型及其命令</title>
    <url>/archives/redis-data-type/</url>
    <content><![CDATA[<p>Redis 是一个 key-value 数据库，key 一般为 String
类型，value类型多种多样。</p>
<p>部分 Redis 数据结构如下：</p>
<table>
<thead>
<tr class="header">
<th>数据类型</th>
<th>举例</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>String</td>
<td>Hello world</td>
<td>基本类型</td>
</tr>
<tr class="even">
<td>Hash</td>
<td>{name: "gtn1024", age: 18}</td>
<td>基本类型</td>
</tr>
<tr class="odd">
<td>List</td>
<td>[A -&gt; B -&gt; C -&gt; C]</td>
<td>基本类型</td>
</tr>
<tr class="even">
<td>Set</td>
<td>{A, B, C}</td>
<td>基本类型</td>
</tr>
<tr class="odd">
<td>SortedSet</td>
<td>{A: 1, B: 2, C: 3}</td>
<td>基本类型</td>
</tr>
<tr class="even">
<td>GEO</td>
<td>{A: (120.3, 30.5) }</td>
<td>特殊类型</td>
</tr>
<tr class="odd">
<td>BitMap</td>
<td>110110101110101000</td>
<td>特殊类型</td>
</tr>
<tr class="even">
<td>HyperLog</td>
<td>110110101110101000</td>
<td>特殊类型</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="redis-通用命令">Redis 通用命令</h2>
<h3 id="keys">KEYS</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">KEYS pattern</span><br><span class="line">summary: Returns all key names that match a pattern.</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">KEYS *</span></span><br><span class="line">1) age</span><br><span class="line">2) name</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">KEYS n*</span></span><br><span class="line">1) name</span><br></pre></td></tr></table></figure>
<h3 id="del">DEL</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">DEL key [key ...]</span><br><span class="line">summary: Deletes one or more keys.</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">KEYS *</span></span><br><span class="line">1) age</span><br><span class="line">2) k1</span><br><span class="line">3) name</span><br><span class="line">4) k3</span><br><span class="line">5) k2</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">DEL name</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">DEL k1 k2 k3</span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">KEYS *</span></span><br><span class="line">1) age</span><br></pre></td></tr></table></figure>
<h3 id="exists">EXISTS</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">EXISTS key [key ...]</span><br><span class="line">summary: Determines whether one or more keys exist.</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">KEYS *</span></span><br><span class="line">1) age</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EXISTS name</span></span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EXISTS age</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="expire-ttl">EXPIRE / TTL</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">EXPIRE key seconds [NX|XX|GT|LT]</span><br><span class="line">summary: Sets the expiration time of a key in seconds.</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br><span class="line"></span><br><span class="line">TTL key</span><br><span class="line">summary: Returns the expiration time in seconds of a key.</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EXPIRE age 20</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TTL age</span></span><br><span class="line">16</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TTL age</span></span><br><span class="line">13</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TTL age</span></span><br><span class="line">13</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">KEYS *</span></span><br><span class="line">1) age</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TTL age</span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TTL age</span></span><br><span class="line">-2</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">KEYS *</span></span><br><span class="line">(empty array)</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash"><span class="built_in">set</span> name gtn1024</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TTL name</span></span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h2 id="string">String</h2>
<p>根据格式的不同，可以分为三类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>常用命令：</p>
<ul>
<li>SET：添加或者修改已经存在的一个 String 类型的键值对</li>
<li>GET：根据 key 获取 String 类型的 value</li>
<li>MSET：批量添加多个 String 类型的键值对</li>
<li>MGET：根据多个 key 获取多个 String 类型的 value</li>
<li>INCR：让一个整型的 key 自增 1</li>
<li>INCRBY：让一个整型的 key
自增并指定步长，例如：<code>INCRBY num 2</code> 让 num 值自增 2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个 String 类型的键值对，前提是这个 key
不存在，否则不执行</li>
<li>SETEX：添加一个 String 类型的键值对，并且指定有效期</li>
</ul>
<p>key 的层级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET a:b:1 ok</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET a:b:2 ok2</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET a:c:1 ok3</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET a:c:2 ok4</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">KEYS *</span></span><br><span class="line">1) a:b:2</span><br><span class="line">2) a:c:1</span><br><span class="line">3) a:c:2</span><br><span class="line">4) a:b:1</span><br></pre></td></tr></table></figure>
<p>使用 Redis 相关 GUI 客户端时，能够自动为其分为层级。</p>
<img src="/archives/redis-data-type/20240714114857.png" class="">
<h2 id="hash">Hash</h2>
<p>String 类型可以将对象序列化为 JSON
字符串后存储，当需要修改对象里某一个字段的时候很不方便。</p>
<img src="/archives/redis-data-type/20240714120350.png" class="">
<p>常用命令：</p>
<ul>
<li>HSET key field value：添加或者修改 hash 类型 key 的 field 的值</li>
<li>HGET key field：获取一个 hash 类型 key 的 field 的值</li>
<li>HMSET：批量添加多个 hash 类型 key 的 field 的值</li>
<li>HMGET：批量获取多个 hash 类型 key 的 field 的值</li>
<li>HGETALL：获取一个 hash 类型的 key 中的所有的 field 和 value</li>
<li>HKEYS：获取一个 hash 类型的 key 中的所有的 field</li>
<li>HVALS：获取一个 hash 类型的 key 中的所有的 value</li>
<li>HINCRBY：让一个 hash 类型 key 的字段值自增并指定步长</li>
<li>HSETNX：添加一个 hash 类型的 key 的 field 值，前提是这个 field
不存在，否则不执行</li>
</ul>
<h2 id="list">List</h2>
<p>Redis 中的 List 类型与 Java 中的 <code>LinkedList</code>
类似，可以看作是一个双向链表的结构。既可以支持正向检索也可以支持反向检索。</p>
<p>特征也与 <code>LinkedList</code> 类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用命令：</p>
<ul>
<li>LPUSH key element ...：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回 nil</li>
<li>RPUSH key element ...：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key starend：返回一段角标范围内的所有元素</li>
<li>BLPOP 和 BRPOP：与 LPOP 和 RPOP
类似，只不过在没有元素时等待指定时间，而不是直接返回 nil</li>
</ul>
<h2 id="set">Set</h2>
<p>Redis 的 Set 结构和 Java 中的 HashSet 类似。</p>
<p>特征也与 <code>HashSet</code> 类似：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p>常用命令：</p>
<ul>
<li>SADD key member ...：向 set 中添加一个或多个元素</li>
<li>SREM key member ...：移除 set 中的指定元素</li>
<li>SCARD key：返回 set 中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于 set 中</li>
<li>SMEMBERS：获取 set 中的所有元素</li>
<li>SINTER key1 key2 ...：求 key1 与 key2 的交集</li>
<li>SDIFF key1 key2 ...：求 key1 与 key2 的差集</li>
<li>SUNION key1 key2 ...：求 key1 和 key2 的并集</li>
</ul>
<h2 id="sortedset">SortedSet</h2>
<p>Redis 的 SortedSet 是一个可排序的 set 集合，与 Java 中的 TreeSet
有点类似，但是底层的数据结构差别很大。</p>
<p>SortedSet 中的每一个元素都带有一个 score 属性，可以基于 score
属性对于元素进行排序，底层实现是一个跳表 + hash 表。</p>
<p>SortedSet 具有下列特征：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为 SortedSet 可排序的特性，经常用来实现排行榜这样的功能。</p>
<p>常用命令：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到 sorted
set，如果已经存在则更新其 score 值</li>
<li>ZREM key member：删除 sorted set 中的一个指定元素</li>
<li>ZSCORE key member：获取 sorted set 中的指定元素的 score 值</li>
<li>ZRANK key member：获取 sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取 sorted set 中的元素个数</li>
<li>ZCOUNT key min max：统计 score 值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让 sorted set
中的指定元素自增，步长为指定的 increment 值</li>
<li>ZRANGE key min max：按照 score 排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照 score 排序后，获取指定 score
范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 小抄</title>
    <url>/archives/ruby-cheatsheet/</url>
    <content><![CDATA[<p>快速入门 Ruby 语法。</p>
<span id="more"></span>
<h2 id="ruby-安装">Ruby 安装</h2>
<ul>
<li><a href="https://rubyinstaller.org/">RubyInstaller for
Windows</a></li>
<li><a href="https://rvm.io/">RVM(Ruby Version Manager)</a></li>
<li><a href="https://github.com/rbenv/rbenv">rbenv</a></li>
</ul>
<h2 id="实用网站">实用网站</h2>
<ul>
<li><a href="https://ruby-china.org/">Ruby China</a></li>
</ul>
<h2 id="标识符">标识符</h2>
<p>一般习惯使用下划线进行单词分隔</p>
<h2 id="注释">注释</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">=end</span></span><br></pre></td></tr></table></figure>
<h2 id="变量常量">变量/常量</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;Ruby&#x27;</span>     <span class="comment"># 变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">VERSION</span> = <span class="string">&#x27;3.2.1&#x27;</span> <span class="comment"># 常量</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">lang = <span class="string">&#x27;ruby&#x27;</span></span><br><span class="line">msg = <span class="string">&quot;I am using <span class="subst">#&#123;lang&#125;</span>&quot;</span>  <span class="comment"># I am using ruby</span></span><br><span class="line">msg = <span class="string">&#x27;I am using <span class="subst">#&#123;lang&#125;</span>&#x27;</span>  <span class="comment"># I am using $&#123;lang&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行字符串</span></span><br><span class="line">puts <span class="string">&lt;&lt;-S</span></span><br><span class="line"><span class="string">  有</span></span><br><span class="line"><span class="string">  多</span></span><br><span class="line"><span class="string">  行</span></span><br><span class="line"><span class="string">S</span></span><br><span class="line"><span class="comment">#  有</span></span><br><span class="line"><span class="comment">#  多</span></span><br><span class="line"><span class="comment">#  行</span></span><br><span class="line"></span><br><span class="line">puts <span class="string">&lt;&lt;~MESSAGE</span></span><br><span class="line"><span class="string">      自动</span></span><br><span class="line"><span class="string">      删除</span></span><br><span class="line"><span class="string">      缩进</span></span><br><span class="line"><span class="string">     MESSAGE</span></span><br><span class="line"><span class="comment"># 自动</span></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="comment"># 缩进</span></span><br></pre></td></tr></table></figure>
<h2 id="数组">数组</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">b = [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">a + b    <span class="comment"># [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, 1, 2, 3]</span></span><br><span class="line">a - b    <span class="comment"># [&quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">a |<span class="params"> b    # [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3]</span></span><br><span class="line"><span class="params">a &amp; b    # [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>
<h2 id="哈希表">哈希表</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">user = &#123;</span><br><span class="line">  <span class="symbol">id:</span> <span class="number">1</span>,</span><br><span class="line">  <span class="symbol">name:</span> <span class="string">&#x27;ruby&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">user[<span class="symbol">:name</span>]  <span class="comment"># ruby</span></span><br></pre></td></tr></table></figure>
<h2 id="空判断">空判断</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当 a 为 nil 时，赋值为 100</span></span><br><span class="line">a |<span class="params"></span>|= <span class="number">100</span></span><br><span class="line">a     <span class="comment"># 100</span></span><br></pre></td></tr></table></figure>
<h2 id="赋值">赋值</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">a, b = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a   <span class="comment"># 1</span></span><br><span class="line">b   <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<h2 id="方法调用">方法调用</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">f1            <span class="comment"># 无参省略小括号（推荐）</span></span><br><span class="line">f1()          <span class="comment"># 无参保留小括号</span></span><br><span class="line"></span><br><span class="line">puts <span class="string">&#x27;hi&#x27;</span>     <span class="comment"># 省略小括号</span></span><br><span class="line">puts(<span class="string">&#x27;hi&#x27;</span>)    <span class="comment"># 保留小括号</span></span><br></pre></td></tr></table></figure>
<h2 id="类">类</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span></span><br><span class="line">    puts <span class="string">&quot;Hi, <span class="subst">#&#123;<span class="variable">@name</span>&#125;</span>!&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.bar</span><br><span class="line">    puts <span class="string">&#x27;Foo, bar!&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">foo = <span class="title class_">Foo</span>.new <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">foo.say   <span class="comment"># Hi, Jack!</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.bar   <span class="comment"># Foo, bar!</span></span><br></pre></td></tr></table></figure>
<h2 id="继承">继承</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span></span><br><span class="line">    puts <span class="string">&quot;Hi, I am <span class="subst">#&#123;<span class="variable">@name</span>&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &lt; <span class="title class_ inherited__">Person</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name, grade</span>)</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable">@grade</span> = grade</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">get_grade</span></span><br><span class="line">    puts <span class="string">&quot;I am grade <span class="subst">#&#123;<span class="variable">@grade</span>&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">stu = <span class="title class_">Student</span>.new(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">stu.say          <span class="comment"># Hi, I am Jack</span></span><br><span class="line">stu.get_grade    <span class="comment"># I am grade 2</span></span><br></pre></td></tr></table></figure>
<h2 id="访问权限">访问权限</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">public_method</span></span><br><span class="line">    puts <span class="string">&#x27;public method&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">protected_method</span></span><br><span class="line">    puts <span class="string">&#x27;protected method&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">private_method</span></span><br><span class="line">    puts <span class="string">&#x27;private method&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">foo = <span class="title class_">Foo</span>.new</span><br><span class="line">foo.public_method      <span class="comment"># public method</span></span><br><span class="line">foo.protected_method   <span class="comment"># ERROR! protected method `protected_method&#x27; called for #&lt;Foo:0x00000001010316f8&gt; (NoMethodError)</span></span><br><span class="line">foo.private_method     <span class="comment"># ERROR! private method `private_method&#x27; called for #&lt;Foo:0x00000001032a61c0&gt; (NoMethodError)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>栈、队列例题分析</title>
    <url>/archives/stack-queue/</url>
    <content><![CDATA[<p><strong>栈</strong>、<strong>队列</strong>
是算法中十分常见的数据结构。</p>
<span id="more"></span>
<h2 id="栈">栈</h2>
<p>栈是一种 FILO （先入后出）的数据结构。关于 <strong>栈</strong>
相关的知识参见 <a
href="/archives/data-structure-stack-queue/#栈-stack">本篇文章</a>
。</p>
<h3 id="栈例-1">栈例 1</h3>
<blockquote>
<p>有 n 个人，按照 1, 2, 3, 4, …, n
的顺序依次进栈。判断是否能够以所给序列出栈。</p>
<p>第一行为样例个数 t，第二行为人数 n。</p>
</blockquote>
<p><strong>输入</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">4 3 2 1</span><br><span class="line">1 2 3 4</span><br><span class="line">1 3 2 4</span><br><span class="line">1 4 2 3</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<p><strong>样例说明</strong>：</p>
<p>样例 1：1 进，2 进，3 进，4 进，4 出，3 出，2 出，1 出。</p>
<p>样例 2：1 进，1 出，2 进，2 出，3 进，3 出，4 进，4 出。</p>
<p>样例 3：1 进，1 出，2 进，3 进，3 出，2 出，4 进，4 出。</p>
<p>样例 4：1 进，1 出，2 进，3 进，4 进，4 出。此时由栈底到栈顶元素为
2、3，出去的元素只能为 3。故该情况不成立。</p>
<p><strong>题目分析</strong>：</p>
<p>使用 j 变量来存储当前判断的输入元素（即 a
数组的下标），持续判断栈顶元素是否等于当前判断元素，如果相等则将该元素从栈中弹出，同时将
j 加一。否则继续向栈中添加元素，重复前面的判断过程。</p>
<p><strong>参考代码</strong>：</p>
<p>C++ 实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">60010</span>];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; T &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      st.<span class="built_in">push</span>(i);</span><br><span class="line">      <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[j] == st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">60010</span>];</span><br><span class="line">    ArrayDeque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (T-- != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = sc.nextInt();</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        st.push(i);</span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; a[j] == st.peek()) &#123;</span><br><span class="line">          st.pop();</span><br><span class="line">          j++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (st.isEmpty())</span><br><span class="line">        System.out.println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈例-2-栈和排序">栈例 2 —— 栈和排序</h3>
<p>题目来源：<a
href="https://ac.nowcoder.com/acm/problem/14893">NC14893</a></p>
<blockquote>
<p>给你一个1-&gt;n的排列和一个栈，入栈顺序给定</p>
<p>你要在不打乱入栈顺序的情况下，对数组进行从大到小排序</p>
<p>当无法完全排序时，请输出字典序最大的出栈序列</p>
</blockquote>
<p><strong>输入描述</strong>:</p>
<blockquote>
<p>第一行一个数n</p>
<p>第二行n个数，表示入栈的顺序，用空格隔开，结尾无空格</p>
</blockquote>
<p><strong>输出描述</strong>：</p>
<blockquote>
<p>输出一行n个数表示答案，用空格隔开，结尾无空格</p>
</blockquote>
<p><strong>样例输入</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 1 5 3 4</span><br></pre></td></tr></table></figure>
<p><strong>样例输出</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 4 3 1 2</span><br></pre></td></tr></table></figure>
<p><strong>样例说明</strong>：</p>
<p>2 入栈；1 入栈；5 入栈；5 出栈；3 入栈；4 入栈；4 出栈；3 出栈；1
出栈；2 出栈</p>
<p><strong>题目分析</strong>：</p>
<p>该题首先将输入数据存入数组
a，并使用数组来存放当前所在元素及其右侧最大的元素。当栈顶元素大于右侧元素时，则可以出栈。</p>
<p><strong>参考代码</strong>：</p>
<p>C++ 实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">6000010</span>], maxn[<span class="number">6000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) maxn[i] = <span class="built_in">max</span>(maxn[i + <span class="number">1</span>], a[i]); <span class="comment">// 记录右侧最大值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    st.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() &gt; maxn[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈例-3-牛牛与后缀表达式">栈例 3 —— 牛牛与后缀表达式</h3>
<p>题目来源：<a
href="https://ac.nowcoder.com/acm/problem/212914">NC212914</a></p>
<blockquote>
<p>给定牛牛一个后缀表达式s，计算它的结果，例如，1+1对应的后缀表达式为<code>1#1#+</code>，<code>#</code>作为操作数的结束符号。</p>
<p>其中，表达式中只含有<code>+</code>、<code>-</code>、<code>*</code>三种运算，不包含除法。</p>
<p>本题保证表达式一定合法，且计算过程和计算结果的绝对值一定不会超过
<span class="math inline">\(10^{18}\)</span></p>
</blockquote>
<p><strong>参数</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;1#1#+&quot;</span><br><span class="line">&quot;12#3#+15#*&quot;</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">225</span><br></pre></td></tr></table></figure>
<p><strong>样例说明</strong>：</p>
<p>样例 1：<code>1#1#+</code>这个后缀表达式表示的式子是<span
class="math inline">\(1+1\)</span>，结果为<span
class="math inline">\(2\)</span></p>
<p>样例 2：<code>12#3#+15#*</code>这个后缀表达式表示的式子是<span
class="math inline">\((12+3)*15\)</span>，结果为<span
class="math inline">\(225\)</span></p>
<p><strong>题目分析</strong>：</p>
<p>该题使用 <strong>栈</strong>
这种数据结构来存储。将数字丢入栈中，如果遇到运算符则将栈顶的两个元素拿出来运算后将结果再次丢入栈中。最终栈中的元素即为结果。</p>
<p>==注意：减法时需要注意正负号==</p>
<p><strong>参考代码</strong>：</p>
<p>Java 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">legalExp</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    ArrayDeque&lt;Long&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">tmp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        st.push(tmp);</span><br><span class="line">        tmp = -<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">a</span> <span class="operator">=</span> st.pop();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">b</span> <span class="operator">=</span> st.pop();</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            st.push(a + b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            st.push(-a + b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            st.push(a * b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp == -<span class="number">1</span>) &#123;</span><br><span class="line">          tmp = (<span class="type">int</span>) (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          tmp *= <span class="number">10L</span>;</span><br><span class="line">          tmp += (<span class="type">int</span>) (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈例-4-好串">栈例 4 —— 好串</h3>
<p>题目来源：<a
href="https://ac.nowcoder.com/acm/problem/21874">NC21874</a></p>
<blockquote>
<p>牛牛喜欢跟字符串玩耍，他刚刚学会了一个新操作，将一个字符串x插入另一个字符串y中（包括放在开头和结尾）</p>
<p>牛牛认为如果一个串是好的当这个串能按照如下方法被构造出来：</p>
<p>一开始，有一个空串，然后执行0次或者若干次操作，每次操作将<code>ab</code>插入当前的字符串</p>
<p>根据上面的定义，<code>ab</code>, <code>aabb</code>,
<code>aababb</code>都是好串，<code>aab</code>,<code>ba</code>,<code>abbb</code>并不是好串</p>
<p>现在给你一个字符串s，判断s是否是好串</p>
</blockquote>
<p><strong>输入描述</strong>：</p>
<blockquote>
<p>输入一行包含一个字符串，长度不超过 50</p>
</blockquote>
<p><strong>输出描述</strong>：</p>
<blockquote>
<p>输出 <code>Good</code> 或者 <code>Bad</code></p>
</blockquote>
<p><strong>样例输入</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ab</span><br><span class="line">aab</span><br><span class="line">abaababababbaabbaaaabaababaabbabaaabbbbbbbb</span><br></pre></td></tr></table></figure>
<p><strong>样例输出</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Good</span><br><span class="line">Bad</span><br><span class="line">Bad</span><br></pre></td></tr></table></figure>
<p><strong>备注</strong>：</p>
<blockquote>
<p>子任务1：n &lt;= 10</p>
<p>子任务2：n &lt;= 20</p>
<p>子任务3：无限制</p>
</blockquote>
<h4 id="使用栈进行操作">使用栈进行操作</h4>
<p>使用栈进行实现，如果字符为
<code>a</code>，则将该字符投入栈中。如果字符为
<code>b</code>，则判断栈顶元素是否为 <code>a</code>。</p>
<p><strong>参考代码</strong>：</p>
<p>C++ 实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">      st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  cout &lt;&lt; (<span class="built_in">solve</span>(s) ? <span class="string">&quot;Good&quot;</span> : <span class="string">&quot;Bad&quot;</span>) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> ArrayDeque&lt;Character&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">solve</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">        st.push(c);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st.isEmpty() &amp;&amp; st.peek() == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">          st.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">st</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    sc.close();</span><br><span class="line">    System.out.println(solve(st) ? <span class="string">&quot;Good&quot;</span> : <span class="string">&quot;Bad&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串操作">字符串操作</h4>
<p>该题也可以直接通过字符串替换进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">solve</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (s.contains(<span class="string">&quot;ab&quot;</span>)) &#123;</span><br><span class="line">      s = s.replace(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.equals(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">st</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    sc.close();</span><br><span class="line">    System.out.println(solve(st) ? <span class="string">&quot;Good&quot;</span> : <span class="string">&quot;Bad&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈练习题">栈练习题</h3>
<ul>
<li><a href="https://ac.nowcoder.com/acm/problem/15029">NC15029 -
吐泡泡</a></li>
<li><a href="https://ac.nowcoder.com/acm/problem/15975">NC15975 -
小C的记事本</a></li>
</ul>
<h2 id="队列">队列</h2>
<p>队列是一种 FIFO （先入先出）的数据结构。关于 <strong>队列</strong>
相关的知识参见 <a
href="/archives/data-structure-stack-queue/#%E9%98%9F%E5%88%97-queue">本篇文章</a>
。</p>
<h3 id="队列例-1-noip2004-合并果子">队列例 1 —— [NOIP2004] 合并果子</h3>
<p><a href="https://ac.nowcoder.com/acm/problem/16663">题目来源</a></p>
<p>要想消耗的体力值最小，必须使得每次合并的重量为最小的两个。该题可以使用
<strong>优先队列</strong> （<strong>Priority
Queue</strong>）进行实现。</p>
<p>优先队列中每一个元素都有一个优先级，优先级高的优先。</p>
<p><strong>参考代码</strong>：</p>
<p>C++ 实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;  <span class="comment">// 升序的优先队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    cin &gt;&gt; tmp;</span><br><span class="line">    pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (pq.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> a = pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b = pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    pq.<span class="built_in">push</span>(a + b);</span><br><span class="line">    ans += a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      pq.offer(sc.nextInt());</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pq.size() !=<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">      <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">      pq.add(a + b);</span><br><span class="line">      ans += a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">    sc.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法知识</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 学习笔记 2——类型（上）</title>
    <url>/archives/ts-datatype-1/</url>
    <content><![CDATA[<p>本文主要介绍如何在 TypeScript 中描述不同类型的对象。</p>
<span id="more"></span>
<p>文章目录：</p>
<ul>
<li><a href="/archives/ts-intro/" title="TypeScript 学习笔记 1——初识TS">TypeScript 学习笔记 1——初识TS</a></li>
<li><a href="/archives/ts-datatype-1/" title="TypeScript 学习笔记 2——类型（上）">TypeScript 学习笔记 2——类型（上）</a></li>
</ul>
<h2 id="数据类型">数据类型</h2>
<p>在 JavaScript 中有如下数据类型：</p>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>bigint</code></li>
<li><code>symbol</code></li>
<li><code>object</code> (包括
<code>Array</code>、<code>Function</code>、<code>Date</code> 等)</li>
</ul>
<p>而 TypeScript 有如下类型</p>
<ul>
<li>JavaScript 中所有数据类型</li>
<li><code>void</code></li>
<li><code>never</code></li>
<li><code>enum</code></li>
<li><code>unknown</code></li>
<li><code>any</code></li>
<li>自定义类型 <code>type</code> (类型别名)、<code>interface</code></li>
</ul>
<h2 id="理解类型">理解类型</h2>
<p>值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> <span class="literal">undefined</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1.1</span> <span class="number">1.2</span> <span class="number">3.1415926</span></span><br><span class="line">a b c d abc</span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span></span><br><span class="line">------------</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;js&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>()</span><br></pre></td></tr></table></figure>
<p>通过集合的思想，对应类型如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">type</span> <span class="built_in">number</span> = <span class="number">1</span> | <span class="number">1.1</span> | <span class="number">1.11</span> | ... | <span class="number">2</span> | ...</span><br><span class="line"><span class="keyword">type</span> <span class="built_in">string</span> = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;ab&#x27;</span> | ...</span><br><span class="line"><span class="keyword">type</span> <span class="built_in">boolean</span> = <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">------------</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Object</span> = &#123; ? &#125; | <span class="title class_">Any</span> | <span class="title class_">Function</span> | <span class="title class_">String</span> | <span class="title class_">Number</span> | <span class="title class_">Boolean</span> | <span class="title class_">RegExp</span> | ...</span><br></pre></td></tr></table></figure>
<p>在开发的过程中，通常不使用包装类型（如
<code>number</code>-<code>Number</code>、<code>boolean</code>-<code>Boolean</code>、<code>string</code>-<code>String</code>）。同时，<code>Object</code>
通常也不使用，因为其表示范围过大。例如，使用 <code>Object</code>
类型可以表示一个数字、数组、函数、正则表达式……</p>
<h2 id="描述对象的数据类型">描述对象的数据类型</h2>
<p>因为在 TypeScript 中使用 <code>Object</code>
类型表示对象，其范围过大。我们通常不用 <code>Object</code>
类型，而是定义特定的类型来描述一个对象。</p>
<h3 id="用-class-constructor-描述">用 class / constructor 描述</h3>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">d</span>: <span class="title class_">Date</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// d 只能为 Date 类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f</span>: <span class="title class_">Function</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// f 只能为函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="title class_">Array</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>]; <span class="comment">// arr 只能为数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">brr</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]; <span class="comment">// brr 只能为元素为 number 类型的数组</span></span><br></pre></td></tr></table></figure>
<h3 id="用-type-或-interface-描述">用 <code>type</code> 或
<code>interface</code> 描述</h3>
<h4 id="定义固定格式的类型">定义固定格式的类型</h4>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，缺少 age</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，多了 gender</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义可变类型">定义可变类型</h4>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  [<span class="attr">k</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: A = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">123</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: A = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">123</span>,</span><br><span class="line"> <span class="attr">b</span>: <span class="number">456</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，value 只能为 number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: A = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">123</span>,</span><br><span class="line"> <span class="attr">b</span>: <span class="string">&#x27;字符串&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用该方法，我们还可以使用 <code>Record</code> 来定义类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> B = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: B = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">123</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: B = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">123</span>,</span><br><span class="line"> <span class="attr">b</span>: <span class="number">456</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，value 只能为 number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: B = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">123</span>,</span><br><span class="line"> <span class="attr">b</span>: <span class="string">&#x27;字符串&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="描述各种对象">描述各种对象</h2>
<h3 id="数组对象">数组对象</h3>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="built_in">string</span>[]</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">AA</span> = <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: A = [<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">aa</span>: <span class="variable constant_">AA</span> = [<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = <span class="built_in">number</span>[]</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">BB</span> = <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: B = [<span class="number">1</span>, <span class="number">0.6</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bb</span>: <span class="variable constant_">BB</span> = [<span class="number">1</span>, <span class="number">0.6</span>]</span><br></pre></td></tr></table></figure>
<p>元组：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = [<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">string</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: A = [<span class="string">&#x27;hi1&#x27;</span>, <span class="string">&#x27;hi2&#x27;</span>, <span class="string">&#x27;hi3&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">1</span>]) <span class="comment">// hi2</span></span><br><span class="line"><span class="comment">// 错误，缺少一个元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">err</span>: A = [<span class="string">&#x27;hi1&#x27;</span>, <span class="string">&#x27;hi2&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">boolean</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: B = [<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = [<span class="built_in">string</span>[], <span class="built_in">number</span>[]]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: C = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], [<span class="number">1</span>, <span class="number">3.14</span>, <span class="number">10086</span>]]</span><br></pre></td></tr></table></figure>
<p>思考题：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// a只能为 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="函数对象">函数对象</h3>
<p>函数类型的定义格式如下：<code>(参数列表) =&gt; 返回值类型</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FnA</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">fnA</span>: <span class="title class_">FnA</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fnA&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AddTwoNum</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">addTwoNum</span>: <span class="title class_">AddTwoNum</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addTwoNum</span>(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>在定义函数时，形参列表可以根据实际的使用情况进行删除（即没用的参数可以不用添加上去），如果前面的参数没有使用到可以使用
<code>_</code>
作为占位符，但是在调用函数的时候要将参数列表写全。同时，形参类型可以省略（类型推导）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FnB</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">aFnB</span>: <span class="title class_">FnB</span> = <span class="function">() =&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">aFnB</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 参数不能省略，返回 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">bFnB</span>: <span class="title class_">FnB</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b <span class="comment">// a、b的参数类型可以省略</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bFnB</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 返回 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cFnB</span>: <span class="title class_">FnB</span> = <span class="function">(<span class="params">_, b</span>) =&gt;</span> b</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cFnB</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 返回 2</span></span><br></pre></td></tr></table></figure>
<p>==如果函数使用了
<code>this</code>，则只能使用普通函数，而不能使用箭头函数。==</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">sayHi</span>: <span class="title class_">SayHi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SayHi</span> = <span class="function">(<span class="params"><span class="variable language_">this</span>: Person, name: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">sayHi</span>: <span class="title class_">SayHi</span> = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says hi to <span class="subst">$&#123;name&#125;</span>!`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: sayHi,</span><br><span class="line">&#125;</span><br><span class="line">p.<span class="title function_">sayHi</span>(<span class="string">&#x27;法外狂徒&#x27;</span>)</span><br><span class="line">sayHi.<span class="title function_">call</span>(p, <span class="string">&#x27;法外狂徒&#x27;</span>)</span><br><span class="line">sayHi.<span class="title function_">apply</span>(p, [<span class="string">&#x27;法外狂徒&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="其他对象">其他对象</h3>
<p>除了普通对象、数组对象、函数对象以外的对象通常使用 <code>class</code>
来描述。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const d: Date = new Date()</span><br><span class="line">const r1: RegExp = /ab+c/</span><br><span class="line">const r2: RegExp = new RegExp(&quot;ab+c&quot;)</span><br><span class="line">const map: Map&lt;string, number&gt; = new Map()</span><br><span class="line">map.set(&#x27;张三&#x27;, 1)</span><br><span class="line">const set: Set&lt;string&gt; = new Set()</span><br><span class="line">set.add(&#x27;1&#x27;)</span><br><span class="line">set.add(&#x27;2&#x27;)</span><br><span class="line">set.add(&#x27;1&#x27;)</span><br></pre></td></tr></table></figure>
<p>事实上，TypeScript 可以根据赋值的类型进行推导：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// Date</span></span><br><span class="line"><span class="keyword">const</span> r1 = <span class="regexp">/ab+c/</span>    <span class="comment">// RegExp </span></span><br><span class="line"><span class="keyword">const</span> r2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;ab+c&quot;</span>) <span class="comment">// RegExp</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;() <span class="comment">// Map&lt;string, number&gt;</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="built_in">string</span>&gt;() <span class="comment">// Set&lt;string&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="any-和-unknown"><code>any</code> 和 <code>unknown</code></h2>
<p><code>any</code> 指可以赋值为任何类型的类型，其不受 TypeScript
类型系统的控制。</p>
<p><code>unknown</code>
指并不知道该对象为什么类型，通常用于从远端返回来的数据。对其进行操作时，需要对其进行类型断言。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">any</span> = <span class="string">&#x27;1,2,3&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="built_in">unknown</span> = <span class="string">&#x27;1,2,3&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((b <span class="keyword">as</span> <span class="built_in">string</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: <span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h2 id="never-类型"><code>never</code> 类型</h2>
<p><code>any</code> 指在 TypeScript 中所有的类型，<code>never</code>
则代表除 <code>any</code> 之外的类型（即其为空集）。出现
<code>never</code> 时通常为错误。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A 的类型为 never</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="built_in">string</span> &amp; <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: B = (<span class="string">&#x27;hello&#x27;</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// b 为 string</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> b === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// b 为 number</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// b 为 never</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 学习笔记 3——类型（下）</title>
    <url>/archives/ts-datatype-2/</url>
    <content><![CDATA[<p>本文主要介绍 TypeScript 种的枚举（<code>enum</code>）类型，以及
<code>type</code> 和 <code>interface</code> 的区别。</p>
<span id="more"></span>
<h2 id="enum"><code>enum</code></h2>
<p>一般在需要进行某种映射关系的时候，使用
<code>enum</code>。例如，从后端获取到某个数据，前端对其进行判断的时候使用，使其更有语义化。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">  <span class="variable constant_">TODO</span> = <span class="number">1</span>, <span class="comment">// 1</span></span><br><span class="line">  <span class="variable constant_">DONE</span>,     <span class="comment">// 2</span></span><br><span class="line">  <span class="variable constant_">ARCHIVED</span>, <span class="comment">// 3</span></span><br><span class="line">  <span class="variable constant_">DELETED</span>,  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 st 是从后端服务器获取到的数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">st</span>: <span class="title class_">Status</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> (st === <span class="title class_">Status</span>.<span class="property">TODO</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;TODO&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (st === <span class="title class_">Status</span>.<span class="property">DONE</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DONE&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (st === <span class="title class_">Status</span>.<span class="property">ARCHIVED</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ARCHIVED&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (st === <span class="title class_">Status</span>.<span class="property">DELETED</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DELETED&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st = <span class="title class_">Status</span>.<span class="property">ARCHIVED</span></span><br></pre></td></tr></table></figure>
<h2 id="type"><code>type</code></h2>
<p><code>type</code>
是指类型别名，用于给其他类型取个名字，而不是产生一个新的数据类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="built_in">string</span>  <span class="comment">// 为 string 取个名叫 Name</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FalseLike</span> = <span class="string">&#x27;&#x27;</span> | <span class="number">0</span> | <span class="literal">null</span> | <span class="literal">undefined</span> | <span class="literal">false</span> <span class="comment">// 代指所有类false的值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125; <span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Points</span> = <span class="title class_">Point</span>[]   <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Line</span> = [<span class="title class_">Point</span>, <span class="title class_">Point</span>] <span class="comment">// 元组</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Circle</span> = &#123; <span class="attr">center</span>: <span class="title class_">Point</span>; <span class="attr">radius</span>: <span class="built_in">number</span> &#125; <span class="comment">// 复杂的对象</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> <span class="comment">// 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有属性的函数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FnWithProps</span> = &#123;</span><br><span class="line">    (<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">    <span class="attr">prop1</span>: <span class="title class_">Name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">fnWithProp</span>: <span class="title class_">FnWithProps</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br><span class="line">fnWithProp.<span class="property">prop1</span> = <span class="string">&#x27;Hi&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="interface"><code>interface</code></h2>
<p><code>interface</code>
用于声明一个接口，描述对象的属性。用于描述一个对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">TA</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IA &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">TB</span> = &#123;</span><br><span class="line">  [<span class="attr">k</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IB &#123;</span><br><span class="line">  [<span class="attr">k</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="type-和-interface-的区别"><code>type</code> 和
<code>interface</code> 的区别</h2>
<ol type="1">
<li><code>interface</code> 只
<strong>描述对象</strong>，<code>type</code> 则描述所有数据。</li>
<li><code>type</code> 仅仅是类型别名，<code>interface</code>
则是类型声明。</li>
<li><code>type</code> 不可以重新赋值，<code>interface</code>
多次定义会合并。</li>
</ol>
<p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般对外的 API 尽量使用 <code>interface</code>，以方便扩展。对内的
API 使用 <code>type</code>，防止代码分散。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 学习笔记 1——初识TS</title>
    <url>/archives/ts-intro/</url>
    <content><![CDATA[<p>本系列主要是在学习方应杭老师的《TypeScript全解》所做笔记。该系列文章可能会结合
Java 上的知识对 TypeScript 进行理解。</p>
<span id="more"></span>
<p>文章目录：</p>
<ul>
<li><a href="/archives/ts-intro/" title="TypeScript 学习笔记 1——初识TS">TypeScript 学习笔记 1——初识TS</a></li>
<li><a href="/archives/ts-datatype-1/" title="TypeScript 学习笔记 2——类型（上）">TypeScript 学习笔记 2——类型（上）</a></li>
</ul>
<h2 id="typescript-是什么">TypeScript 是什么</h2>
<p>TypeScript 是添加了类型系统的 JavaScript，是 JavaScript
的超集。所有的 JavaScript 代码都是合法的 TypeScript 代码。</p>
<h2 id="类型擦除是什么">类型擦除是什么</h2>
<p>普通的 JavaScript 代码可以在 Chrome、Node 等环境中直接运行，而
TypeScript 无法在无任何其他工具的帮助下直接运行。</p>
<img src="/archives/ts-intro/20220825201047.png" class="">
<p>类型擦除指将 TypeScript 代码中与类型相关的东西移除，变为纯真的
JavaScript 代码。通常也可以称它为编译的过程。</p>
<p>编译 TypeScript 主要有如下工具：</p>
<ul>
<li>esbuild</li>
<li>swc</li>
<li>tsc</li>
<li>babel</li>
</ul>
<p>其中，esbuild 和 swc 在编译时不会检查 TS
语法，仅仅将类型擦除，故其在使用时十分快速。而 tsc 和 babel 工具会检查
TS 语法，如果 TS 语法错误则无法进行编译，故编译过程较慢。</p>
<h3 id="使用-esbuild-编译-ts-代码">使用 <code>esbuild</code> 编译 TS
代码</h3>
<p>首先使用 npm 安装 <code>esbuild</code>
工具：<code>npm i -g esbuild</code></p>
<p>用于测试的代码如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.ts</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">number</span> = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>
<p>使用 <code>esbuild 1.ts</code> 命令编译结果如下：</p>
<img src="/archives/ts-intro/20220825202237.png" class="">
<p>可以看到，<code>esbuild</code> 将 <code>number</code> 移除了。</p>
<p>如果需要将编译后的结果输出到文件，可以使用重定向符将标准输出转移到文件。</p>
<p><code>esbuild 1.ts &gt; 1.js</code></p>
<img src="/archives/ts-intro/20220825202541.png" class="">
<h3 id="使用-swc-编译-ts-代码">使用 <code>swc</code> 编译 TS 代码</h3>
<p>使用 <code>npm i -g @swc/cli @swc/core</code> 安装 swc</p>
<img src="/archives/ts-intro/20220825202730.png" class="">
<h3 id="使用-tsc-编译-ts-代码">使用 <code>tsc</code> 编译 TS 代码</h3>
<p><code>tsc</code> 是 TypeScript 官方提供的编译工具，安装 TypeScript
后将自带该工具。</p>
<p><code>npm i -g typescript</code></p>
<img src="/archives/ts-intro/20220825203026.png" class="">
<h3 id="不检查-ts-语法是什么意思">不检查 TS 语法是什么意思</h3>
<p>不检查 TS 语法是指工具在编译 TS
的过程中不对其正确性进行检查，仅仅将类型删去。</p>
<p>例如，我在 <code>bad.ts</code> 的文件中将 <code>number</code> 写成
<code>numbe</code>，<code>esbuild</code> 可以正常输出编译结果，而
<code>tsc</code> 会报错。</p>
<img src="/archives/ts-intro/20220825203337.png" class="">
<h2 id="运行-typescript-代码">运行 TypeScript 代码</h2>
<h3 id="typescript-playground">TypeScript Playground</h3>
<p>TypeScript Playground 是 TypeScript
官方提供的演练场，有大量的配置可以修改。在学习 TypeScript
语法时可以使用该演练场进行代码编写。</p>
<img src="/archives/ts-intro/20220825204400.png" class="">
<img src="/archives/ts-intro/20220825204341.png" class="">
<h3 id="使用-ts-node-执行-typescript-代码">使用 <code>ts-node</code>
执行 TypeScript 代码</h3>
<p>在系统中全局安装 <code>ts-node</code>（需要有 TypeScript 环境）</p>
<p><code>npm i -g ts-node</code></p>
<p>安装后就可以使用 <code>ts-node</code> 命令直接运行 TS 代码</p>
<img src="/archives/ts-intro/20220825205116.png" class="">
<h3 id="使用-esno-执行-typescript-代码">使用 <code>esno</code> 执行
TypeScript 代码</h3>
<p>同样使用 npm 安装工具：<code>npm i -g esno</code></p>
<p>随后使用 <code>esno</code> 运行，效果与 <code>ts-node</code> 类似</p>
<img src="/archives/ts-intro/20220825205515.png" class="">
]]></content>
      <categories>
        <category>编程语言</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 搭建 C++ 开发环境</title>
    <url>/archives/vscode-cpp-dev/</url>
    <content><![CDATA[<p><strong>VSCode</strong>(Visual Studio
Code)是一款由微软开发且跨平台的轻量级编辑器。可通过各种插件扩展实现各个编程语言的开发（如
C/C++、Python、Java 等）。</p>
<span id="more"></span>
<h2 id="编译器安装">编译器安装</h2>
<h3 id="windows-系统">Windows 系统</h3>
<p>按照 <a
href="https://mirrors.tuna.tsinghua.edu.cn/help/msys2/">清华大学镜像源
msys2</a> 页面的方法，安装
MSYS2，并且可以根据提示配置相应的镜像源。<strong>注意：安装过程中需要保证通畅的网络。</strong></p>
<img src="/archives/vscode-cpp-dev/16308512143077.jpg" class="">
<p>打开<code>C:\msys64\msys2_shell.cmd</code>，执行<code>pacman -Syu</code></p>
<img src="/archives/vscode-cpp-dev/16308525279806.jpg" class="">
<p>重新打开<code>C:\msys64\msys2_shell.cmd</code>，输入<code>pacman -Su</code>，过程同上。</p>
<img src="/archives/vscode-cpp-dev/16308526276557.jpg" class="">
<p>再次执行<code>pacman -S --needed base-devel mingw-w64-x86_64-toolchain</code>，中途遇到提示直接全部按回车即可，耐心等待安装完成。</p>
<h4 id="环境变量配置">环境变量配置</h4>
<p>打开<strong>高级系统设置</strong>，点击<strong>环境变量</strong></p>
<img src="/archives/vscode-cpp-dev/16308516376436.jpg" class="">
<img src="/archives/vscode-cpp-dev/16308516645060.jpg" class="">
<p>在<code>Path</code>变量中新建一项，设置为<code>C:\msys64\mingw64\bin</code>(如果修改过安装路径请对应修改一下)</p>
<img src="/archives/vscode-cpp-dev/16308517461734.jpg" class="">
<h3 id="macos-系统">macOS 系统</h3>
<p>打开<strong>终端</strong>，输入<code>clang --version</code>，如果能够显示如下信息则无需操作。</p>
<img src="/archives/vscode-cpp-dev/16308545298009.jpg" class="">
<p>如果没有安装，输入<code>xcode-select --install</code>安装<strong>Clang</strong>编译器。</p>
<h3 id="linux-系统">Linux 系统</h3>
<p>一般而言，Linux 系统是自带了 gcc 环境的，如未安装，可以手动安装
gcc、g++、gdb 等工具。</p>
<h2 id="vscode-安装及配置">VSCode 安装及配置</h2>
<h3 id="vscode-安装">VSCode 安装</h3>
<p>打开 <a href="https://code.visualstudio.com/">VSCode
官网</a>，下载安装即可。</p>
<h3 id="vscode-插件安装">VSCode 插件安装</h3>
<img src="/archives/vscode-cpp-dev/16308503645361.jpg" class="">
<p>打开 VSCode
后，点击<strong>扩展</strong>(<strong>Extensions</strong>)图标，依次安装
<a
href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++
扩展</a> 、 <a
href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code
Runner</a> 扩展。如果看英文不顺眼的话，可以另外安装 <a
href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">Chinese
(Simplified) Language Pack for Visual Studio Code</a> 中文语言包。</p>
<h3 id="vscode-配置">VSCode 配置</h3>
<h4 id="使用-code-runner-插件无法调试">使用 Code Runner
插件（无法调试）</h4>
<p>打开设置面板，找到<strong>Run In
Terminal</strong>选项，将其打上勾（不开启将无法输入数据）。</p>
<img src="/archives/vscode-cpp-dev/16308504905915.jpg" class="">
<p>输入以下代码，保存为<code>hello.cpp</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击右上角类似播放器的按钮，如果看到下方显示<code>Hello, world!</code>则表示安装成功。</p>
<img src="/archives/vscode-cpp-dev/16429114514875.jpg" class="">
<h4 id="使用-vscode-对-c-程序进行调试">使用 VSCode 对 C++
程序进行调试</h4>
<p>打开项目目录，点击<strong>Run and
Debug</strong>选项卡，点击<strong>Run and
Debug</strong>按钮。出现上方菜单选择<strong>C++(GDB/LLDB)</strong>，即使用
GDB/LLDB 工具链进行调试。</p>
<img src="/archives/vscode-cpp-dev/16429124914878.jpg" class="">
<p>在菜单中选择 <code>g++</code> 即可，如果你使用的是
mac，可以选择<code>clang++</code>。</p>
<img src="/archives/vscode-cpp-dev/16429125670204.jpg" class="">
<p>随后会出现一份配置文件，如果没有个性化需求可以直接关闭该配置。</p>
<img src="/archives/vscode-cpp-dev/16429126495795.jpg" class="">
<p>运行程序可以直接点击上方的调试按钮（<kbd>F5</kbd>），当然在此之前你可以在代码上打断点。</p>
<img src="/archives/vscode-cpp-dev/16429128213147.jpg" class="">
<p><strong>注意</strong>：<del>使用 Apple Silicon 芯片的 mac 用户截至
2022 年 1 月需要通过 <a
href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a>
插件进行调试，具体配置见插件页面。</del></p>
<p><strong>2022 年 3 月 24 日更</strong>：根据 <a
href="https://github.com/microsoft/vscode-cpptools/issues/6779">ISSUE
6779</a> ，目前官方插件已支持 ARM 架构 mac，有兴趣的同学可以试试。</p>
]]></content>
      <categories>
        <category>实用技巧</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>VSCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
